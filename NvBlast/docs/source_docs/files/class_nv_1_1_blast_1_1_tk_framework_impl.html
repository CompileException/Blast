<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.0 Source Reference: Nv::Blast::TkFrameworkImpl Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_nv.html">Nv</a>::<a class="el" href="namespace_nv_1_1_blast.html">Blast</a>::<a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html">TkFrameworkImpl</a>
  </div>
</div>
<div class="contents">
<h1>Nv::Blast::TkFrameworkImpl Class Reference</h1><!-- doxytag: class="Nv::Blast::TkFrameworkImpl" --><!-- doxytag: inherits="Nv::Blast::TkFramework" --><code>#include &lt;<a class="el" href="_nv_blast_tk_framework_impl_8h-source.html">NvBlastTkFrameworkImpl.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Nv::Blast::TkFrameworkImpl:</div>
<div class="dynsection">

<p><center><img src="class_nv_1_1_blast_1_1_tk_framework_impl.png" usemap="#Nv::Blast::TkFrameworkImpl_map" border="0" alt=""></center>
<map name="Nv::Blast::TkFrameworkImpl_map">
<area href="class_nv_1_1_blast_1_1_tk_framework.html" alt="Nv::Blast::TkFramework" shape="rect" coords="0,0,165,24">
</map>
</div>

<p>
<a href="class_nv_1_1_blast_1_1_tk_framework_impl-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#8abe98c41d659ecdeb70b722450b56be">createActor</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a> &amp;desc) override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#e30026ed8aabfdba83d2180dabfae9eb">createAsset</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *assetLL, <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_joint_desc.html">Nv::Blast::TkAssetJointDesc</a> *jointDescs=nullptr, uint32_t jointDescCount=0, bool ownsAsset=false) override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#d45cd110c344066b7bf50fd2743beb82">createAsset</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a> &amp;desc) override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_group.html">TkGroup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#62cf99de17faea824364a987b165a1eb">createGroup</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a> &amp;desc) override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#a2c0a8e8db4ba338bc7c35db417ce122">createJoint</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a> &amp;desc) override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_serializable.html">TkSerializable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#38b505f3e84a26e516ac99c5aea19761">deserialize</a> (physx::general_PxIOStream2::PxFileBuf &amp;stream) override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#60e047e544757a625b123fb633194d80">ensureAssetExactSupportCoverage</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount) const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#30c107f6e6a83b7eba0de851bc67af73">findObjectByID</a> (const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;id) const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#95f2ae1d3cce13ce93fdde0c06b7c097">findObjectByIDInternal</a> (const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;id) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
physx::PxAllocatorCallback &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#f1b9ce36da7494909359b1ec4656d604">getAllocatorCallback</a> () const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">physx::PxAllocatorCallback &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#73ba3c8e350e7809c8f3c530bcc73a0e">getAllocatorCallbackInternal</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual physx::PxErrorCallback &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#51a2ec81f3dbb75b170319602e2cb5c4">getErrorCallback</a> () const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">physx::PxErrorCallback &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#e24103f12d39e5feeac7c8a9a16f09ad">getErrorCallbackInternal</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#496780a06857ea9f04b456c51d655d40">getLogFn</a> () const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#4332119be0c96bc812f2911cb9528ffd">getObjectCount</a> (const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;type) const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#4a37480572a0969d2fddf4a476961a08">getObjects</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> **buffer, uint32_t bufferSize, const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;type, uint32_t indexStart=0) const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#f17ad50dbc2f17eeb2f9172bf86a09d0">getType</a> (<a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html#57681ffd26c84b5272b7e0c23103493a">TkTypeIndex::Enum</a> typeIndex) const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#02e6e8f6fb26c87d096fe501141d73f9">onCreate</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_joint_impl.html">TkJointImpl</a> &amp;joint)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#d279a5f9eea8897839418d4088bdaf78">onCreate</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> &amp;object)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#51d2b34e36404fa15e239d479b64ec11">onDestroy</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_joint_impl.html">TkJointImpl</a> &amp;joint)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#104e730a31ea2d8d344f93ffe787892a">onDestroy</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> &amp;object)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#5da9dfe8dc817432877ab39647d11daa">onIDChange</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> &amp;object, const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;IDPrev, const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;IDCurr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#9375502b9aadd680afa1bd2e3fba9e48">release</a> () override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#e9676d87343ea45be3dd1e83ad937f54">reorderAssetDescChunks</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *bondDescs, uint32_t bondCount, uint32_t *chunkReorderMap=nullptr) const override</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#7ad98d012d6711e09985ef334f89c538">serializeHeader</a> (const <a class="el" href="class_nv_1_1_blast_1_1_tk_serializable.html">TkSerializable</a> &amp;object, physx::general_PxIOStream2::PxFileBuf &amp;stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#35d33007587949a1569388ba5fec8459">TkFrameworkImpl</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_framework_desc.html">TkFrameworkDesc</a> &amp;desc)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#b9761e9be425a9ddb71f1293920e11ac">~TkFrameworkImpl</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#a38e2caa47f9ae268d4326ae7f5dd020">alloc</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function with the std::malloc signature which returns 16-byte aligned memory.  <a href="#a38e2caa47f9ae268d4326ae7f5dd020"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#b98bfbc3392010df818f7bb538902cd0">free</a> (void *mem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function with the std::free signature which can deallocate memory created by alloc.  <a href="#b98bfbc3392010df818f7bb538902cd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html">TkFrameworkImpl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#0c7167f8fd55e170e52cd194c597ad18">get</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#8d8f4af0889c747672c929ad50f34221">log</a> (int type, const char *msg, const char *file, int line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function with the NvBlastLog signature which can be used in NvBlast low-level function calls.  <a href="#8d8f4af0889c747672c929ad50f34221"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html#822f1e27b1a3cca2442f7576cb40d25b">set</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html">TkFrameworkImpl</a> *framework)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implementation of <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html">TkFramework</a> <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="35d33007587949a1569388ba5fec8459"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::TkFrameworkImpl" ref="35d33007587949a1569388ba5fec8459" args="(const TkFrameworkDesc &amp;desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nv::Blast::TkFrameworkImpl::TkFrameworkImpl           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_framework_desc.html">TkFrameworkDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b9761e9be425a9ddb71f1293920e11ac"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::~TkFrameworkImpl" ref="b9761e9be425a9ddb71f1293920e11ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nv::Blast::TkFrameworkImpl::~TkFrameworkImpl           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a38e2caa47f9ae268d4326ae7f5dd020"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::alloc" ref="a38e2caa47f9ae268d4326ae7f5dd020" args="(size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* Nv::Blast::TkFrameworkImpl::alloc           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function with the std::malloc signature which returns 16-byte aligned memory. 
<p>

</div>
</div><p>
<a class="anchor" name="8abe98c41d659ecdeb70b722450b56be"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::createActor" ref="8abe98c41d659ecdeb70b722450b56be" args="(const TkActorDesc &amp;desc) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a>* Nv::Blast::TkFrameworkImpl::createActor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an actor from the given descriptor. The actor will be the first member of a new <a class="el" href="class_nv_1_1_blast_1_1_tk_family.html">TkFamily</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The actor descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created actor, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#30b4f2c95a00aa2cd98a3ba4001b0cb8">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="e30026ed8aabfdba83d2180dabfae9eb"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::createAsset" ref="e30026ed8aabfdba83d2180dabfae9eb" args="(const NvBlastAsset *assetLL, Nv::Blast::TkAssetJointDesc *jointDescs=nullptr, uint32_t jointDescCount=0, bool ownsAsset=false) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a>* Nv::Blast::TkFrameworkImpl::createAsset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>assetLL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_joint_desc.html">Nv::Blast::TkAssetJointDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>jointDescs</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>jointDescCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ownsAsset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an asset from a low-level <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assetLL</em>&nbsp;</td><td>The low-level <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> to encapsulate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jointDescs</em>&nbsp;</td><td>Optional joint descriptors to add to the new asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jointDescCount</em>&nbsp;</td><td>The number of joint descriptors in the jointDescs array. If non-zero, jointDescs cannot be NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ownsAsset</em>&nbsp;</td><td>Does this <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> own the <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> and thus is responsible for freeing it.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created asset, if memory was available for the operation. Otherwise, returns NULL. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#9f9ae6a30e80b39d3fcbb14483c20646">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="d45cd110c344066b7bf50fd2743beb82"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::createAsset" ref="d45cd110c344066b7bf50fd2743beb82" args="(const TkAssetDesc &amp;desc) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a>* Nv::Blast::TkFrameworkImpl::createAsset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an asset from the given descriptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The asset descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created asset, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#f1279d3414ad43036ff3e9e4b37e0a43">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="62cf99de17faea824364a987b165a1eb"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::createGroup" ref="62cf99de17faea824364a987b165a1eb" args="(const TkGroupDesc &amp;desc) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_group.html">TkGroup</a>* Nv::Blast::TkFrameworkImpl::createGroup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a group from the given descriptor. A group is a processing unit, to which the user may add TkActors. New actors generated from splitting a <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a> are automatically put into the same group. However, any actor may be removed from its group and optionally placed into another group, or left groupless.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The group descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created group, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#fbb1cce46ef38bf0a3fb2a5e1b4e2499">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="a2c0a8e8db4ba338bc7c35db417ce122"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::createJoint" ref="a2c0a8e8db4ba338bc7c35db417ce122" args="(const TkJointDesc &amp;desc) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a>* Nv::Blast::TkFrameworkImpl::createJoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a joint from the given descriptor. The following restrictions apply:<p>
Only one joint may be created between any two support chunks.<p>
A joint cannot be created between chunks within the same actor using this method. See <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a> for a description of bond joint flags, which will create internal joints within an actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The joint descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created joint, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#40b557778256cd6589a3b174015c3029">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="38b505f3e84a26e516ac99c5aea19761"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::deserialize" ref="38b505f3e84a26e516ac99c5aea19761" args="(physx::general_PxIOStream2::PxFileBuf &amp;stream) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_serializable.html">TkSerializable</a>* Nv::Blast::TkFrameworkImpl::deserialize           </td>
          <td>(</td>
          <td class="paramtype">physx::general_PxIOStream2::PxFileBuf &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserialize an object from the given stream. Only objects derived from <a class="el" href="class_nv_1_1_blast_1_1_tk_serializable.html">TkSerializable</a> may be serialized and deserialized. Use the parent class method <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html#d156c3e85ee665c251e26ac86d3cf03b">TkIdentifiable::getType()</a> to know the type to which to cast the object.<p>
Notes for different classes:<p>
<a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a>: deserializing a serialized <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> will recreate the asset in memory with the same <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> (see <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html#610a75ccff6579e5e54a59f2840f6630">TkIdentifiable::getID()</a>) as the original asset.<p>
<a class="el" href="class_nv_1_1_blast_1_1_tk_family.html">TkFamily</a>: deserializing a serialized <a class="el" href="class_nv_1_1_blast_1_1_tk_family.html">TkFamily</a> will generate all <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a> and <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a> objects that were originally contained in the family. The <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> which generated the family must exist at the time the family is deserialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>User-defined stream object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer the deserialized object if successful, or NULL if unsuccessful. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#902537856fc43e0d4dd04f9d1ba47bbf">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="60e047e544757a625b123fb633194d80"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::ensureAssetExactSupportCoverage" ref="60e047e544757a625b123fb633194d80" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount) const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Nv::Blast::TkFrameworkImpl::ensureAssetExactSupportCoverage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function to ensure (check and update) support coverage of chunks, required for asset creation via the createAsset function.<p>
This is a convenience wrapper for the low-level NvBlastEnsureAssetExactSupportCoverage function.<p>
The chunk descriptors may have their support flags be modified to ensure exact coverage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>An array of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The size of the chunkDescs array.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff coverage was already exact. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#80df575e224678953bd5ae33ac7ab22d">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="30c107f6e6a83b7eba0de851bc67af73"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::findObjectByID" ref="30c107f6e6a83b7eba0de851bc67af73" args="(const NvBlastID &amp;id) const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a>* Nv::Blast::TkFrameworkImpl::findObjectByID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up an object derived from <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> by its ID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the object to look up (see <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer the object if it exists, NULL otherwise. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#d6f25c2fa686ebe78a612ad657b6745f">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="95f2ae1d3cce13ce93fdde0c06b7c097"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::findObjectByIDInternal" ref="95f2ae1d3cce13ce93fdde0c06b7c097" args="(const NvBlastID &amp;id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> * Nv::Blast::TkFrameworkImpl::findObjectByIDInternal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal (non-virtual) method to find a <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> object based upon its <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a>. 
</div>
</div><p>
<a class="anchor" name="b98bfbc3392010df818f7bb538902cd0"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::free" ref="b98bfbc3392010df818f7bb538902cd0" args="(void *mem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Nv::Blast::TkFrameworkImpl::free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function with the std::free signature which can deallocate memory created by alloc. 
<p>

</div>
</div><p>
<a class="anchor" name="0c7167f8fd55e170e52cd194c597ad18"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::get" ref="0c7167f8fd55e170e52cd194c597ad18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html">TkFrameworkImpl</a>* Nv::Blast::TkFrameworkImpl::get           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the global singleton. 
</div>
</div><p>
<a class="anchor" name="f1b9ce36da7494909359b1ec4656d604"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getAllocatorCallback" ref="f1b9ce36da7494909359b1ec4656d604" args="() const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual physx::PxAllocatorCallback&amp; Nv::Blast::TkFrameworkImpl::getAllocatorCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the allocator callback set by the user. 
<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#10c01b13eb802dc0262a93d248729055">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="73ba3c8e350e7809c8f3c530bcc73a0e"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getAllocatorCallbackInternal" ref="73ba3c8e350e7809c8f3c530bcc73a0e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE physx::PxAllocatorCallback &amp; Nv::Blast::TkFrameworkImpl::getAllocatorCallbackInternal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the allocator callback set by the user. 
</div>
</div><p>
<a class="anchor" name="51a2ec81f3dbb75b170319602e2cb5c4"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getErrorCallback" ref="51a2ec81f3dbb75b170319602e2cb5c4" args="() const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual physx::PxErrorCallback&amp; Nv::Blast::TkFrameworkImpl::getErrorCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the error callback set by the user. 
<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#d2155df8d8391e7682f3c93cf74db9ef">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="e24103f12d39e5feeac7c8a9a16f09ad"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getErrorCallbackInternal" ref="e24103f12d39e5feeac7c8a9a16f09ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE physx::PxErrorCallback &amp; Nv::Blast::TkFrameworkImpl::getErrorCallbackInternal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the error callback set by the user. 
</div>
</div><p>
<a class="anchor" name="496780a06857ea9f04b456c51d655d40"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getLogFn" ref="496780a06857ea9f04b456c51d655d40" args="() const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> Nv::Blast::TkFrameworkImpl::getLogFn           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to a log function which can be used in <a class="el" href="namespace_nv_1_1_blast.html">Blast</a> low-level calls. This function uses the user-supplied PxErrorCallback (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_framework_desc.html">TkFrameworkDesc</a>). 
<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#033e4c2f304ee859140a9c972ef12e75">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="4332119be0c96bc812f2911cb9528ffd"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getObjectCount" ref="4332119be0c96bc812f2911cb9528ffd" args="(const TkType &amp;type) const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t Nv::Blast::TkFrameworkImpl::getObjectCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of TkIdentifiable-derived objects in the framework of the given type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type object for the given type.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of objects that currently exist of the given type. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#58225ad807e6aa4c2b54a7ede92fcabf">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="4a37480572a0969d2fddf4a476961a08"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getObjects" ref="4a37480572a0969d2fddf4a476961a08" args="(TkIdentifiable **buffer, uint32_t bufferSize, const TkType &amp;type, uint32_t indexStart=0) const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t Nv::Blast::TkFrameworkImpl::getObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>indexStart</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve an array of pointers (into the user-supplied buffer) to TkIdentifiable-derived objects of the given type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>A user-supplied array of <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of elements available to write into buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type object for the given type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>indexStart</em>&nbsp;</td><td>The starting index of the object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> pointers written to the buffer. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#0de2324a24540ad80fff89f808532160">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="f17ad50dbc2f17eeb2f9172bf86a09d0"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::getType" ref="f17ad50dbc2f17eeb2f9172bf86a09d0" args="(TkTypeIndex::Enum typeIndex) const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a>* Nv::Blast::TkFrameworkImpl::getType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html#57681ffd26c84b5272b7e0c23103493a">TkTypeIndex::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>typeIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To find the type information for a given TkIdentifiable-derived class, use this funtion with the <a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html#57681ffd26c84b5272b7e0c23103493a">TkTypeIndex::Enum</a> corresponding to the desired class name.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeIndex</em>&nbsp;</td><td>Enumerated object type (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html">TkTypeIndex</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>type object associated with the object's class. </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#c675c056796a68b29fb303b135eab416">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="8d8f4af0889c747672c929ad50f34221"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::log" ref="8d8f4af0889c747672c929ad50f34221" args="(int type, const char *msg, const char *file, int line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Nv::Blast::TkFrameworkImpl::log           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A function with the NvBlastLog signature which can be used in NvBlast low-level function calls. 
<p>

</div>
</div><p>
<a class="anchor" name="02e6e8f6fb26c87d096fe501141d73f9"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::onCreate" ref="02e6e8f6fb26c87d096fe501141d73f9" args="(TkJointImpl &amp;joint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::TkFrameworkImpl::onCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_joint_impl.html">TkJointImpl</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>joint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Special onCreate method for joints, since they are not <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a>. 
</div>
</div><p>
<a class="anchor" name="d279a5f9eea8897839418d4088bdaf78"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::onCreate" ref="d279a5f9eea8897839418d4088bdaf78" args="(TkIdentifiable &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::TkFrameworkImpl::onCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To be called by any <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> object when it is created, so the framework can track it. 
</div>
</div><p>
<a class="anchor" name="51d2b34e36404fa15e239d479b64ec11"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::onDestroy" ref="51d2b34e36404fa15e239d479b64ec11" args="(TkJointImpl &amp;joint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::TkFrameworkImpl::onDestroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_joint_impl.html">TkJointImpl</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>joint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Special onDestroy method for joints, since they are not <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a>. 
</div>
</div><p>
<a class="anchor" name="104e730a31ea2d8d344f93ffe787892a"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::onDestroy" ref="104e730a31ea2d8d344f93ffe787892a" args="(TkIdentifiable &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::TkFrameworkImpl::onDestroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To be called by any <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> object when it is deleted, so the framework can stop tracking it. 
</div>
</div><p>
<a class="anchor" name="5da9dfe8dc817432877ab39647d11daa"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::onIDChange" ref="5da9dfe8dc817432877ab39647d11daa" args="(TkIdentifiable &amp;object, const NvBlastID &amp;IDPrev, const NvBlastID &amp;IDCurr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::TkFrameworkImpl::onIDChange           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>IDPrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>IDCurr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Must be called whenever a <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> object's ID is changed, so that the framework can associate the new ID with it. 
</div>
</div><p>
<a class="anchor" name="9375502b9aadd680afa1bd2e3fba9e48"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::release" ref="9375502b9aadd680afa1bd2e3fba9e48" args="() override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Nv::Blast::TkFrameworkImpl::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release this framework and all contained objects. Global singleton is set to NULL. 
<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#c98d733dfdddbbcfa806b4c282e17aa0">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="e9676d87343ea45be3dd1e83ad937f54"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::reorderAssetDescChunks" ref="e9676d87343ea45be3dd1e83ad937f54" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, NvBlastBondDesc *bondDescs, uint32_t bondCount, uint32_t *chunkReorderMap=nullptr) const override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Nv::Blast::TkFrameworkImpl::reorderAssetDescChunks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>bondDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bondCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkReorderMap</em> = <code>nullptr</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function to build and apply chunk reorder map, so that chunk descriptors are properly ordered for the createAsset function.<p>
This is a convenience wrapper for the low-level NvBlastReorderAssetDescChunks function.<p>
This function may modify both the chunkDescs and bondDescs array, since rearranging chunk descriptors requires re-indexing within the bond descriptors.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>Array of chunk descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondDescs</em>&nbsp;</td><td>Array of bond descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondCount</em>&nbsp;</td><td>The number of bond descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkReorderMap</em>&nbsp;</td><td>If not NULL, must be a pointer to a uint32_t array of size desc.chunkCount. Maps old chunk indices to the reordered chunk indices.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the chunks did not require reordering (chunkReorderMap is the identity map). </dd></dl>

<p>Implements <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#58b670d4e37ebb15894d00ed3abfe648">Nv::Blast::TkFramework</a>.</p>

</div>
</div><p>
<a class="anchor" name="7ad98d012d6711e09985ef334f89c538"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::serializeHeader" ref="7ad98d012d6711e09985ef334f89c538" args="(const TkSerializable &amp;object, physx::general_PxIOStream2::PxFileBuf &amp;stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Nv::Blast::TkFrameworkImpl::serializeHeader           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_nv_1_1_blast_1_1_tk_serializable.html">TkSerializable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::general_PxIOStream2::PxFileBuf &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialize a TkSerializable's standard header data, including its type ID, type version, object ID, and TkObject::userIntData. 
</div>
</div><p>
<a class="anchor" name="822f1e27b1a3cca2442f7576cb40d25b"></a><!-- doxytag: member="Nv::Blast::TkFrameworkImpl::set" ref="822f1e27b1a3cca2442f7576cb40d25b" args="(TkFrameworkImpl *framework)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Nv::Blast::TkFrameworkImpl::set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework_impl.html">TkFrameworkImpl</a> *&nbsp;</td>
          <td class="paramname"> <em>framework</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the global singleton, if it's not already set, or set it to NULL. Returns true iff successful. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>sdk/toolkit/source/<a class="el" href="_nv_blast_tk_framework_impl_8h-source.html">NvBlastTkFrameworkImpl.h</a></ul>
</div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
