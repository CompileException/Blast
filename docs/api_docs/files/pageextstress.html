<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 API Reference: Stress Solver Extension (NvBlastExtStress)</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="pageextstress">Stress Solver Extension (NvBlastExtStress) </a></h1>The Blast&trade; stress solver extension provides implementation of quite fast and easy to use stress solver which works directly with bond graph. It simulates more complex damage model on support graph by allowing to apply forces on nodes of support graph (on chunks). The most common usage is just applying gravity force on a static construction so that it will fall apart at some point when carcass can't hold anymore. Dynamic actors are also supported, you could for example add centrifugal force so that rotating object fast enough will break bonds.<p>
It is also can be used as an another way to apply impact damage, which can give visually pleasant result of breaking actor in a weak place instead of the place of contact.<p>
<br>
 <h2><a class="anchor" name="stresssolverfeatures">
Features</a></h2>
<ul>
<li>Requires only core <em>NvBlast</em> </li><li>Supports both static and dynamic actors</li><li>Propagates both linear and angular momentum</li><li>Graph complexity selection (reduces support graph to smaller size trade off speed and quality)</li><li>Apply stress damage on Blast Actor</li><li>Debug Render</li></ul>
<p>
<br>
 <h2><a class="anchor" name="stresssolvertunning">
Settings Tuning</a></h2>
Computational time is linearly proprtional to <em>bondIterationsPerFrame</em> setting. To fine tune look for balance between <em>bondIterationsPerFrame</em> and <em>graphReductionLevel</em> . The more bond iterations are set the more precise computation will be. The smaller graph allows to make higher fidelity computations witihing the same bond iterations per frame (same time spent), but actual cracks (damaged bonds) will be more sparsed as the result.<p>
Debug render could help a lot with that, consider using <em>stressSolver-&gt;fillDebugRender</em>(...) for that.<p>
<br>
 <h2><a class="anchor" name="stresssolverusage">
Usage</a></h2>
In order to use it create an instance with <em>ExtStressSolver::create</em>(...).<p>
<div class="fragment"><pre class="fragment">ExtStressSolver* stressSolver = ExtStressSolver::create(family, settings);
</pre></div><p>
<em>ExtStressSolverSettings</em> are passed in create function, but also can be changed at any time with <em>stressSolver-&gt;setSettings</em>(...).<p>
It fully utilizes the fact that it knows initial support graph structure and does maximum of processing in <em>create</em>(...) method calls. After that all actors split calls are synced internally quite fast and only the actual stress propagation takes most of computational time.<p>
Then you need to provide physics specific information (mass, volume, position, static) for every node in support graph since Blast itself is physics agnostic. There are two ways to do it, you can call <em>stressSolver-&gt;setNodeInfo</em>(...) for every graph node. Another was is to call stressSolver-&gt;setAllNodesInfoFromLL() once all the data will be populated using <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> chunk's data, in particular <em>volume</em> and <em>centroid</em> are used. All nodes connected to 'world' chunk are marked as static.<p>
<div class="fragment"><pre class="fragment">stressSolver-&gt;setAllNodesInfoFromLL();
</pre></div><p>
Stress solver needs to keep track for actor create/destroy events in order to update it's internal stress graph accordingly. So you need to call <em>stressSolver-&gt;notifyActorCreated(actor)</em> and <em>stressSolver-&gt;notifyActorDestroyed(actor)</em> every time actor is created or destroyed including the initial actor family had when stress solver were created. There is no need to track actors which contain only one or lesser graph nodes in that case <em>notifyActorCreated(actor)</em> returns 'false' as a hint, it means that stress solver will ignore them. For those actors applying forces is also doesn't make any sense.<p>
Typical update loop would can look like this:<p>
<ol type=1>
<li>If split happend call relevant stressSolver-&gt;notifyActorCreated(actor) and stressSolver-&gt;notifyActorDestroyed(actor)</li><li>Apply all forces, use <em>stressSolver-&gt;addForce</em>(...), stressSolver-&gt;addGravityForce(...), <em>stressSolver-&gt;addAngularVelocity</em>(...)</li><li>Call <em>stressSolver-&gt;update()</em>. This is where all expensive computation happens.</li><li>If <em>stressSolver-&gt;getOverstressedBondCount()</em> &gt; 0 use one of <em>stressSolver-&gt;generateFractureCommands()</em> methods to get bond fracture commands and apply on them actors.</li></ol>
<p>
Example code from ExtPxStressSolverImpl:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ExtPxStressSolverImpl::onActorCreated(ExtPxFamily&amp; <span class="comment">/*family*/</span>, ExtPxActor&amp; actor)
{
    <span class="keywordflow">if</span> (m_solver-&gt;notifyActorCreated(*actor.getTkActor().getActorLL()))
    {
        m_actors.insert(&amp;actor);
    }
}

<span class="keywordtype">void</span> ExtPxStressSolverImpl::onActorDestroyed(ExtPxFamily&amp; <span class="comment">/*family*/</span>, ExtPxActor&amp; actor)
{
    m_solver-&gt;notifyActorDestroyed(*actor.getTkActor().getActorLL());
    m_actors.erase(&amp;actor);
}

<span class="keywordtype">void</span> ExtPxStressSolverImpl::update(<span class="keywordtype">bool</span> doDamage)
{
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = m_actors.getIterator(); !it.done(); ++it)
    {
        <span class="keyword">const</span> ExtPxActor* actor = *it;

        PxRigidDynamic&amp; rigidDynamic = actor-&gt;getPhysXActor();
        <span class="keyword">const</span> <span class="keywordtype">bool</span> isStatic = rigidDynamic.getRigidBodyFlags() &amp; PxRigidBodyFlag::eKINEMATIC;
        <span class="keywordflow">if</span> (isStatic)
        {
            PxVec3 gravity = rigidDynamic.getScene()-&gt;getGravity();
            PxVec3 localGravity = rigidDynamic.getGlobalPose().rotateInv(gravity);

            m_solver-&gt;addGravityForce(*actor-&gt;getTkActor().getActorLL(), localGravity);
        }
        <span class="keywordflow">else</span>
        {
            PxVec3 localCenterMass = rigidDynamic.getCMassLocalPose().p;
            PxVec3 localAngularVelocity = rigidDynamic.getGlobalPose().rotateInv(rigidDynamic.getAngularVelocity());
            m_solver-&gt;addAngularVelocity(*actor-&gt;getTkActor().getActorLL(), localCenterMass, localAngularVelocity);
        }
    }

    m_solver-&gt;update();

    <span class="keywordflow">if</span> (doDamage &amp;&amp; m_solver-&gt;getOverstressedBondCount() &gt; 0)
    {
        <a class="code" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> commands;
        m_solver-&gt;generateFractureCommands(commands);
        <span class="keywordflow">if</span> (commands.<a class="code" href="struct_nv_blast_fracture_buffers.html#6e0a226d98a23de576d376c4bf9fc356" title="available elements in bondFractures">bondFractureCount</a> &gt; 0)
        {
            m_family.getTkFamily().applyFracture(&amp;commands);
        }
    }
}
</pre></div><p>
Have a look at <em>ExtPxStressSolver</em> implementation code, which is basically high level wrapper on <em>NvBlastExtStress</em> to couple it with PhysX&trade; and <em>NvBlatExtPx</em> extension (see <a class="el" href="pageextphysx.html#extpxstresssolver">ExtPxStressSolver</a>).<p>
<br>
 </div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
