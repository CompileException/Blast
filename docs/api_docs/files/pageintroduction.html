<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.0 API Reference: Introduction</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="pageintroduction">Introduction </a></h1>Blast&trade; is an NVIDIA GameWorks&trade; destruction library. It consists of a <a class="el" href="pagellapi.html">Low Level API (NvBlast)</a>, a <a class="el" href="pagehlapi.html">High Level (Toolkit) API (NvBlastTk)</a> (Blast&trade; Toolkit or BlastTk), and <a class="el" href="pageextapi.html">Extensions (NvBlastExt)</a> (Blast&trade; Extensions or BlastExt). This layered API is designed to allow short ramp-up time for first usage (through the Ext and Tk APIs) while also allowing for customization and optimization by experienced users through the low-level API.<p>
This library is intended to replace APEX Destruction. It is being developed with years of user feedback and experience, with the goal of addressing shortcomings in performance, stability, and customizability of the APEX Destruction module.<h2><a class="anchor" name="asset_structure">
Asset Structure</a></h2>
Blast&trade; is currently designed to support rigid body, pre-fractured destruction. Future versions may support runtime fracturing or deformation.<p>
The static data associated with a destructible is stored in an <em>asset</em>. Assets are instanced into actors, which may be damaged and fractured. When fractured, actors are broken into pieces called <em>chunks</em>. Connected groups of chunks belong to new actors. The grouping of chunks into actors is determined by the support graph in the asset.<p>
Chunks are defined hierarchically, so that when a chunk is fractured its child chunks are created. The user may tag any chunk in this hierarchy as a <em>support</em> chunk. This is covered in more detail in the <a class="el" href="pageintroduction.html#support_model">Support Model</a> section. The user also supplies a description of the connections between support chunks. A <em>bond</em> represents the surface joining neighboring chunks. A bond is represented by a surface centroid, an average surface normal, and the surface area. These quantities don't need to be exact for Blast&trade; to operate effectively.<p>
Multiple chunk hierarchies may exist in a single asset. The <em>root chunks</em> (see <a class="el" href="pagedefinitions.html">Definitions</a>) will be visible when the asset is initially instanced. Subsequent fracturing has the effect of breaking the root chunks into their hierarchical descendants.<h2><a class="anchor" name="support_model">
Support Model</a></h2>
Blast&trade; requires that support chunks form an <em>exact cover</em> (see the definition of exact coverage in <a class="el" href="pagedefinitions.html">Definitions</a>). However, it is quite forgiving with respect to user input when creating an asset. The geometric interpretation of exact coverage is that the support chunks fill the space of the root (unfractured) chunk, without any volume being covered by more than one chunk. Upon asset creation, missing coverage will be filled in by Blast&trade;, by assigning support to chunks at the highest place possible (closest to root) in the hierarchy. If support is redundant, that is a chunk and one of its descendant chunks are both marked as support by the user, then Blast&trade; will remove support from the descendant chunk.<p>
Support chunks that are joined by bonds will be grouped together in the same actor when fracturing occurs. In order to take advantage of the chunk hieararchy to reduce the number of chunks which represent an actor physically and graphically, Blast&trade; calculates a list of <em>visible chunks</em> from the support chunks in an actor. These may be the support chunks, or they may be ancestors of support chunks if all descendant support chunks are in the actor.<p>
Support chunks do not have to be leaves in the chunk hierarchy, nor do they have to be at the same depth in the hierarchy. Children of support chunks will always be the sole chunk in their actor, since there is no bond defined between them. If an actor consists of of a <em>subsupport chunk</em> (see <a class="el" href="pagedefinitions.html">Definitions</a>), the visible chunk is the same chunk.<h2><a class="anchor" name="damage_model">
Damage Model</a></h2>
Damage is defined as loss of an actor's material integrity. This is modeled by a simple health value associated with the bonds and chunks in the support graph. The user applies damage to an actor at a given location, with a maximum effect radius. The resulting loss of bond and chunk health is determined by a user-defined <em>material function</em>. In this way the user can customize the effect of damage based upon the bonds' properties such as normal and area, as well as distance from impact location.<p>
Damage is applied from a damage event buffer. After all damage events are processed, bonds with non-positive healths are considered to be broken. Blast&trade; performs island detection on the support graph to find all groups of support chunks that are connected by unbroken bonds, and any new islands found result in new actors.<p>
If an actor is composed of a single support or subsupport chunk with subsupport descendants, then there is no bond structure to model damage. Instead, such a chunk is considered to have its own health value, which may be decreased by damage. When such a lower-support (see <a class="el" href="pagedefinitions.html">Definitions</a>) chunk's health is non-positive, its associated actor is deleted and replaced by actors that represent its child chunks, if any.<p>
The effect of damage on leaf chunks depends upon which API is used. The low-level API does not delete leaf chunks. It is up to the user to delete them, and manage their physical and graphical representation outside of Blast&trade; if so desired.<h2><a class="anchor" name="backwards_compatibility">
Backwards Compatibility</a></h2>
The Blast&trade; SDK provides the <a class="el" href="pageimporter.html">ApexImporter</a> tool to allow APEX Destructible assets to be reused. A Blast&trade; asset requires more information in its support graph than an APEX Destuctible asset does. Whereas the latter only contains a list of chunk neighbors, the bonds used by Blast&trade; include a small amount of geometric information, as described in <a class="el" href="pageintroduction.html#asset_structure">Asset Structure</a>.<p>
<br>
 </div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
