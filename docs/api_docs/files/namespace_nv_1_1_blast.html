<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 API Reference: Nv::Blast Namespace Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespace_nv.html">Nv</a>::<a class="el" href="namespace_nv_1_1_blast.html">Blast</a>
  </div>
<div class="contents">
<h1>Nv::Blast Namespace Reference</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast_1_1_apex_importer.html">ApexImporter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast_1_1_vec_math.html">VecMath</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_allocator.html">Allocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_allocator_callback.html">AllocatorCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for an application defined memory allocator that can be used by toolkit (Tk) or any extension (Ext).  <a href="class_nv_1_1_blast_1_1_allocator_callback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_array.html">Array</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_authoring_result.html">AuthoringResult</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_blast_bond_generator.html">BlastBondGenerator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_bond_generation_config.html">BondGenerationConfig</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_chunk_info.html">ChunkInfo</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_collision_hull.html">CollisionHull</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_convex_mesh_builder.html">ConvexMeshBuilder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_d_link.html">DLink</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_d_list.html">DList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_d_list_it.html">DListIt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_edge.html">Edge</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_error_callback.html">ErrorCallback</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User defined interface class. Used by the library to emit debug information.  <a href="class_nv_1_1_blast_1_1_error_callback.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_error_code.html">ErrorCode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error codes.  <a href="struct_nv_1_1_blast_1_1_error_code.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_exporter_mesh_data.html">ExporterMeshData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_custom_profiler.html">ExtCustomProfiler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_force_mode.html">ExtForceMode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_group_task_manager.html">ExtGroupTaskManager</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_impact_damage_manager.html">ExtImpactDamageManager</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_impact_settings.html">ExtImpactSettings</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_profile_data.html">ExtProfileData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_actor_desc_template.html">ExtPxActorDescTemplate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_px_asset.html">ExtPxAsset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_asset_desc.html">ExtPxAssetDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_chunk.html">ExtPxChunk</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_px_family.html">ExtPxFamily</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_family_desc.html">ExtPxFamilyDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_px_listener.html">ExtPxListener</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_px_manager.html">ExtPxManager</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_object_type_i_d.html">ExtPxObjectTypeID</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_shape_desc_template.html">ExtPxShapeDescTemplate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_spawn_settings.html">ExtPxSpawnSettings</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_px_stress_solver.html">ExtPxStressSolver</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_px_subchunk.html">ExtPxSubchunk</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_serialization.html">ExtSerialization</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_stress_solver.html">ExtStressSolver</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_stress_solver_settings.html">ExtStressSolverSettings</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_ext_sync.html">ExtSync</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_sync_event.html">ExtSyncEvent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_sync_event_family_sync.html">ExtSyncEventFamilySync</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_sync_event_fracture.html">ExtSyncEventFracture</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_sync_event_instance.html">ExtSyncEventInstance</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_sync_event_physics_sync.html">ExtSyncEventPhysicsSync</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ext_sync_event_type.html">ExtSyncEventType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_facet.html">Facet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_fixed_array.html">FixedArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_fixed_bitmap.html">FixedBitmap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_fixed_bool_array.html">FixedBoolArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_fixed_priority_queue.html">FixedPriorityQueue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_fracture_tool.html">FractureTool</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_hash_map.html">HashMap</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_hash_set.html">HashSet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_i_fbx_file_reader.html">IFbxFileReader</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_i_mesh_file_reader.html">IMeshFileReader</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_i_mesh_file_writer.html">IMeshFileWriter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_index_d_link.html">IndexDLink</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_index_d_list.html">IndexDList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_inline_array.html">InlineArray</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_iterator_base.html">IteratorBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_json_collision_exporter.html">JsonCollisionExporter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_less.html">Less</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_l_list_it.html">LListIt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_ll_object_type_i_d.html">LlObjectTypeID</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_mesh.html">Mesh</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_mesh_cleaner.html">MeshCleaner</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_plane_chunk_indexer.html">PlaneChunkIndexer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_profiler_callback.html">ProfilerCallback</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_profiler_detail.html">ProfilerDetail</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_random_generator_base.html">RandomGeneratorBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_slicing_configuration.html">SlicingConfiguration</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_time.html">Time</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_data.html">TkActorData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_joint_desc.html">TkAssetJointDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_event.html">TkEvent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_event_listener.html">TkEventListener</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_family.html">TkFamily</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_fracture_commands.html">TkFractureCommands</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_fracture_events.html">TkFractureEvents</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html">TkFramework</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_group.html">TkGroup</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_group_stats.html">TkGroupStats</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_group_worker.html">TkGroupWorker</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_data.html">TkJointData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_update_event.html">TkJointUpdateEvent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_object.html">TkObject</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_object_type_i_d.html">TkObjectTypeID</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_split_event.html">TkSplitEvent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html">TkTypeIndex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_triangle.html">Triangle</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_triangle_indexed.html">TriangleIndexed</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_nv_1_1_blast_1_1_vertex.html">Vertex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_voronoi_sites_generator.html">VoronoiSitesGenerator</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#1cbcf5b75f7db9e3dc15c3a1d99415c5">ExtImpactDamageFunction</a> )(void *data, <a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a> *actor, physx::PxShape *shape, physx::PxVec3 worldPos, physx::PxVec3 worldForce)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef physx::PxJoint *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#6a12664dba0567a600473d48d62a7e86">ExtPxCreateJointFunction</a> )(<a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a> *actor0, const physx::PxTransform &amp;localFrame0, <a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a> *actor1, const physx::PxTransform &amp;localFrame1, physx::PxPhysics &amp;physics, <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a> &amp;joint)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NV_INLINE T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#c0c6da9c519d92d57c310200989092dc">align16</a> (T value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#a0a1acaf4abe11be6cfdcf14cecf4818">atomicDecrement</a> (volatile int32_t *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#02d7c995394a2e2c7f0b18ee051bec2f">atomicIncrement</a> (volatile int32_t *val)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#97fb8332eab5d39661e80f1c4359ca28">createIndexStartLookup</a> (T *lookup, T indexBase, T indexRange, T *indexSource, T indexCount, T indexByteStride)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NV_FORCE_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#0ce4dc5d3f1f248d05a6b699ccaa68b9">findClosestNode</a> (const float point[4], const uint32_t firstGraphNodeIndex, const uint32_t *familyGraphNodeIndexLinks, const uint32_t *adjacencyPartition, const uint32_t *adjacentNodeIndices, const uint32_t *adjacentBondIndices, const <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> *bonds, const float *bondHealths, const uint32_t *chunkIndices)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NV_FORCE_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#174a03926806454cd726b130462606b0">findClosestNode</a> (const float point[4], const uint32_t firstGraphNodeIndex, const uint32_t *familyGraphNodeIndexLinks, const uint32_t *adjacencyPartition, const uint32_t *adjacentNodeIndices, const uint32_t *adjacentBondIndices, const <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> *assetBonds, const float *bondHealths, const <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> *assetChunks, const float *supportChunkHealths, const uint32_t *chunkIndices)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NV_INLINE T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#c1fa2bac8c635169faa133e5de246da9">invalidIndex</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#b0cb52654c117f03fb31826ce2747bfa">invertMap</a> (T *inverseMap, const T *map, const T size)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NV_INLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#a5e952ab38e3501215eee523cb0a0d20">isInvalidIndex</a> (T index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NV_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#1152c58af94417b6861e5bb3695b9ddf">logLL</a> (int type, const char *msg, const char *file, int line)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NV_INLINE T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#4dec47108a96068464a694e46a0dc1a2">pointerOffset</a> (const void *p, ptrdiff_t offset)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NV_INLINE T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_nv_1_1_blast.html#d1e732d6cd2e5f40a0187f05820e9e7e">pointerOffset</a> (void *p, ptrdiff_t offset)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="1cbcf5b75f7db9e3dc15c3a1d99415c5"></a><!-- doxytag: member="Nv::Blast::ExtImpactDamageFunction" ref="1cbcf5b75f7db9e3dc15c3a1d99415c5" args=")(void *data, ExtPxActor *actor, physx::PxShape *shape, physx::PxVec3 worldPos, physx::PxVec3 worldForce)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="namespace_nv_1_1_blast.html#1cbcf5b75f7db9e3dc15c3a1d99415c5">Nv::Blast::ExtImpactDamageFunction</a>)(void *data, <a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a> *actor, physx::PxShape *shape, physx::PxVec3 worldPos, physx::PxVec3 worldForce)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Custom Damage Function 
</div>
</div><p>
<a class="anchor" name="6a12664dba0567a600473d48d62a7e86"></a><!-- doxytag: member="Nv::Blast::ExtPxCreateJointFunction" ref="6a12664dba0567a600473d48d62a7e86" args=")(ExtPxActor *actor0, const physx::PxTransform &amp;localFrame0, ExtPxActor *actor1, const physx::PxTransform &amp;localFrame1, physx::PxPhysics &amp;physics, TkJoint &amp;joint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef physx::PxJoint*(* <a class="el" href="namespace_nv_1_1_blast.html#6a12664dba0567a600473d48d62a7e86">Nv::Blast::ExtPxCreateJointFunction</a>)(<a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a> *actor0, const physx::PxTransform &amp;localFrame0, <a class="el" href="class_nv_1_1_blast_1_1_ext_px_actor.html">ExtPxActor</a> *actor1, const physx::PxTransform &amp;localFrame1, physx::PxPhysics &amp;physics, <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a> &amp;joint)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function pointer for PxJoint creation.<p>
It will be called when new joints are being created. It should return valid PxJoint pointer or nullptr. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c0c6da9c519d92d57c310200989092dc"></a><!-- doxytag: member="Nv::Blast::align16" ref="c0c6da9c519d92d57c310200989092dc" args="(T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE T Nv::Blast::align16           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility function to align the given value to the next 16-byte boundary.<p>
Returns the aligned value. 
</div>
</div><p>
<a class="anchor" name="a0a1acaf4abe11be6cfdcf14cecf4818"></a><!-- doxytag: member="Nv::Blast::atomicDecrement" ref="a0a1acaf4abe11be6cfdcf14cecf4818" args="(volatile int32_t *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Nv::Blast::atomicDecrement           </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="02d7c995394a2e2c7f0b18ee051bec2f"></a><!-- doxytag: member="Nv::Blast::atomicIncrement" ref="02d7c995394a2e2c7f0b18ee051bec2f" args="(volatile int32_t *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Nv::Blast::atomicIncrement           </td>
          <td>(</td>
          <td class="paramtype">volatile int32_t *&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="97fb8332eab5d39661e80f1c4359ca28"></a><!-- doxytag: member="Nv::Blast::createIndexStartLookup" ref="97fb8332eab5d39661e80f1c4359ca28" args="(T *lookup, T indexBase, T indexRange, T *indexSource, T indexCount, T indexByteStride)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::createIndexStartLookup           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>lookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>indexBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>indexRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>indexSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>indexByteStride</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a lookup table for data sorted by a templated index type.<p>
Note: when using this function with unsigned integer index types <a class="el" href="namespace_nv_1_1_blast.html#c1fa2bac8c635169faa133e5de246da9">invalidIndex&lt;T&gt;()</a> is treated as a value less than zero.<p>
On input:<p>
The indices must lie in the interval [indexBase, indexBase+indexRange].<p>
indexSource must point to the first index in the data.<p>
indexCount must be set to the number of indices in the data.<p>
indexByteStride must be set to the distance, in bytes, between subequent indices.<p>
lookup must point to a T array of size indexRange+2.<p>
On return:<p>
lookup will be filled such that:<p>
lookup[i] = the position of first data element with index (i + indexBase)<p>
lookup[indexRange+1] = indexCount<p>
The last (indexRange+1) element is used so that one may always determine the number of data elements with the given index using:<p>
count = lookup[i+1] - lookup[i]<p>
Note, if an index (i + indexBase) is not present in the data then, lookup[i+1] = lookup[i], so the count (above) will correctly be zero. In this case, the actual value of lookup[i] is irrelevant. 
</div>
</div><p>
<a class="anchor" name="0ce4dc5d3f1f248d05a6b699ccaa68b9"></a><!-- doxytag: member="Nv::Blast::findClosestNode" ref="0ce4dc5d3f1f248d05a6b699ccaa68b9" args="(const float point[4], const uint32_t firstGraphNodeIndex, const uint32_t *familyGraphNodeIndexLinks, const uint32_t *adjacencyPartition, const uint32_t *adjacentNodeIndices, const uint32_t *adjacentBondIndices, const NvBlastBond *bonds, const float *bondHealths, const uint32_t *chunkIndices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FORCE_INLINE uint32_t Nv::Blast::findClosestNode           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>point</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>firstGraphNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>familyGraphNodeIndexLinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>adjacencyPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>adjacentNodeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>adjacentBondIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> *&nbsp;</td>
          <td class="paramname"> <em>bonds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>bondHealths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkIndices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the closest node to point in the graph. Uses primarily distance to bond centroids. Slower compared to chunk based lookup but may yield better accuracy in some cases. Bond normals are expected to be directed from the lower to higher node index. Cannot be used for graph actors with only the world chunk in the graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>the point to test against </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>firstGraphNodeIndex</em>&nbsp;</td><td>the entry point for familyGraphNodeIndexLinks </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>familyGraphNodeIndexLinks</em>&nbsp;</td><td>the list index links of the actor's graph </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adjacencyPartition</em>&nbsp;</td><td>the actor's SupportGraph adjacency partition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adjacentNodeIndices</em>&nbsp;</td><td>the actor's SupportGraph adjacent node indices </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adjacentBondIndices</em>&nbsp;</td><td>the actor's SupportGraph adjacent bond indices </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assetBonds</em>&nbsp;</td><td>the actor's asset bonds </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondHealths</em>&nbsp;</td><td>the actor's bond healths </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkIndices</em>&nbsp;</td><td>maps node index to chunk index in SupportGraph</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the node closest to point </dd></dl>

</div>
</div><p>
<a class="anchor" name="174a03926806454cd726b130462606b0"></a><!-- doxytag: member="Nv::Blast::findClosestNode" ref="174a03926806454cd726b130462606b0" args="(const float point[4], const uint32_t firstGraphNodeIndex, const uint32_t *familyGraphNodeIndexLinks, const uint32_t *adjacencyPartition, const uint32_t *adjacentNodeIndices, const uint32_t *adjacentBondIndices, const NvBlastBond *assetBonds, const float *bondHealths, const NvBlastChunk *assetChunks, const float *supportChunkHealths, const uint32_t *chunkIndices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_FORCE_INLINE uint32_t Nv::Blast::findClosestNode           </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>point</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>firstGraphNodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>familyGraphNodeIndexLinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>adjacencyPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>adjacentNodeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>adjacentBondIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> *&nbsp;</td>
          <td class="paramname"> <em>assetBonds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>bondHealths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> *&nbsp;</td>
          <td class="paramname"> <em>assetChunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&nbsp;</td>
          <td class="paramname"> <em>supportChunkHealths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkIndices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the closest node to point in the graph. Uses primarily distance to chunk centroids. Bond normals are expected to be directed from the lower to higher node index. Cannot be used for graph actors with only the world chunk in the graph.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>the point to test against </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>firstGraphNodeIndex</em>&nbsp;</td><td>the entry point for familyGraphNodeIndexLinks </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>familyGraphNodeIndexLinks</em>&nbsp;</td><td>the list index links of the actor's graph </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adjacencyPartition</em>&nbsp;</td><td>the actor's SupportGraph adjacency partition </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adjacentNodeIndices</em>&nbsp;</td><td>the actor's SupportGraph adjacent node indices </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>adjacentBondIndices</em>&nbsp;</td><td>the actor's SupportGraph adjacent bond indices </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assetBonds</em>&nbsp;</td><td>the actor's asset bonds </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondHealths</em>&nbsp;</td><td>the actor's bond healths </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assetChunks</em>&nbsp;</td><td>the actor's asset chunks </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>supportChunkHealths</em>&nbsp;</td><td>the actor's graph chunks healths </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkIndices</em>&nbsp;</td><td>maps node index to chunk index in SupportGraph</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the node closest to point </dd></dl>

</div>
</div><p>
<a class="anchor" name="c1fa2bac8c635169faa133e5de246da9"></a><!-- doxytag: member="Nv::Blast::invalidIndex" ref="c1fa2bac8c635169faa133e5de246da9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE T Nv::Blast::invalidIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set to invalid index. 
</div>
</div><p>
<a class="anchor" name="b0cb52654c117f03fb31826ce2747bfa"></a><!-- doxytag: member="Nv::Blast::invertMap" ref="b0cb52654c117f03fb31826ce2747bfa" args="(T *inverseMap, const T *map, const T size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::invertMap           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>inverseMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates the inverse of a map, such that inverseMap[map[i]] = i. Unmapped indices are set to invalidIndex&lt;T&gt;.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>inverseMap</em>&nbsp;</td><td>inverse map space of given size </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>map</em>&nbsp;</td><td>original map of given size, unmapped entries must contain invalidIndex&lt;T&gt; </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>size of the involved maps </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5e952ab38e3501215eee523cb0a0d20"></a><!-- doxytag: member="Nv::Blast::isInvalidIndex" ref="a5e952ab38e3501215eee523cb0a0d20" args="(T index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::isInvalidIndex           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test for invalid index (max representable integer). 
</div>
</div><p>
<a class="anchor" name="1152c58af94417b6861e5bb3695b9ddf"></a><!-- doxytag: member="Nv::Blast::logLL" ref="1152c58af94417b6861e5bb3695b9ddf" args="(int type, const char *msg, const char *file, int line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE void Nv::Blast::logLL           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Logging wrapper compatible with NvBlastLog. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>.</dd></dl>
Pass this function to LowLevel function calls in order to get logging into global <a class="el" href="class_nv_1_1_blast_1_1_error_callback.html" title="User defined interface class. Used by the library to emit debug information.">ErrorCallback</a>. 
</div>
</div><p>
<a class="anchor" name="4dec47108a96068464a694e46a0dc1a2"></a><!-- doxytag: member="Nv::Blast::pointerOffset" ref="4dec47108a96068464a694e46a0dc1a2" args="(const void *p, ptrdiff_t offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE const void * Nv::Blast::pointerOffset           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d1e732d6cd2e5f40a0187f05820e9e7e"></a><!-- doxytag: member="Nv::Blast::pointerOffset" ref="d1e732d6cd2e5f40a0187f05820e9e7e" args="(void *p, ptrdiff_t offset)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE void * Nv::Blast::pointerOffset           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Offset void* pointer by 'offset' bytes helper-functions 
</div>
</div><p>
</div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
