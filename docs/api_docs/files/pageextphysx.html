<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 API Reference: PhysX Extensions (NvBlastExtPhysX)</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="pageextphysx">PhysX Extensions (NvBlastExtPhysX) </a></h1>NvBlastExtPhysX contains classes for easier use of Blast Toolkit with the PhysX SDK. There are 3 of them:<ul>
<li><b>ExtPxManager</b>: Manager to keep Blast Actors in sync with PhysX actors.</li><li><b>ExtImpactDamageManager</b>: Manager to collect and apply impact damage caused by collision in PhysX Scene.</li><li><b>ExtPxStressSolver</b>: Stress Solver to propagate stress through support graph and apply it as damage to Blast actors.</li></ul>
<p>
This library also contains an extension for synchronizing Blast state:<ul>
<li><b>ExtSync</b> - Utility for writing Blast state to a buffer, to be read by a client. This may be used for networking, for example.</li></ul>
<p>
<br>
 <h2><a class="anchor" name="ExtPxManager">
ExtPxManager</a></h2>
<b>Physics Manager</b> - is a reference implementation for keeping Blast Actors synced with PhysX actors. It's main job is to listen for TkFamily events and update <em>PxScene</em> (by adding and removing PxActors) accordingly.<p>
In order to use it create an ExtPxManager. If we have a physx::PxPhysics object m_physics and a TkFramework m_tkFramework, use<p>
<div class="fragment"><pre class="fragment">ExtPxManager* pxManager = ExtPxManager::create(m_physics, m_tkFramework);
</pre></div><p>
For every <em>TkAsset</em> prepare <em>ExtPxAsset</em>. Which contains <em>TkAsset</em> + collection of physics geometry for every chunk. Every chunk can contain any number of subchunks. Where each subchunk is basically PxConvexMeshGeometry with transform. Also every chunk can be marked as static (<em>isStatic</em> flag). If actor contains at least one static chunks in it's support graph it makes an actor kinematic (static), otherwise it's dynamic. Having zero subchunks makes chunk invisible in physics scene, it can be used for example to represent 'earth' as a special invisible static chunk and connect all near earth chunks to it.<p>
To create a <em>ExtPxFamily</em> from an <em>ExtPxAsset:</em> <p>
<div class="fragment"><pre class="fragment">ExtPxFamilyDesc familyDesc;
familyDesc.pxAsset = pxAsset;
familyDesc.group = tkGroup;
familyDesc.actorDesc.initialBondHealths = <span class="keyword">nullptr</span>;
familyDesc.actorDesc.initialSupportChunkHealths = <span class="keyword">nullptr</span>;
familyDesc.actorDesc.uniformInitialBondHealth = BOND_HEALTH_MAX;
familyDesc.actorDesc.uniformInitialLowerSupportChunkHealth = 1.0f;
ExtPxFamily* family = pxManager-&gt;createFamily(desc);
</pre></div><p>
You can subscribe to family events in order to sync graphics (or anything else) with physics:<p>
<div class="fragment"><pre class="fragment">family-&gt;subscribe(listener);
</pre></div><p>
The listener will be notified with all physics actors added and removed.<p>
And finally spawn the family in some world position (the first actor/actors will be created and event will be fired to the listener):<p>
<div class="fragment"><pre class="fragment">ExtPxSpawnSettings spawnSettings = {
    &amp;pxScene,
    defaultPxMaterial,
    RIGIDBODY_DENSITY
};

family-&gt;spawn(PxTransform(0, 0, 0), PxVec3(1, 1, 1), spawnSettings);
</pre></div><p>
You can get families actor's either from listening to events or by calling getActors(). Every <em>ExtPxActor</em> matches 1 &lt;-&gt; 1 with TkActor (which matches <em><a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a></em> accordingly).<p>
<div class="fragment"><pre class="fragment">ExtPxActor* actor = ....; 
physx::PxRigidDynamic rigidDynamic = actor-&gt;getPxActor(); <span class="comment">// </span>
</pre></div><p>
An ExtPxActor remains internally unchanged through its lifetime. Use <em>ExtPxActor</em> <em>getChunkIndices()</em> and <em>getPxActor()</em> to update your graphics representation. Sample code:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> uint32_t* chunkIndices;
<span class="keywordtype">size_t</span> chunkIndexCount;
actor.getChunkIndices(chunkIndices, chunkIndexCount);
<span class="keywordflow">for</span> (uint32_t i = 0; i &lt; chunkIndexCount; i++)
{
    uint32_t chunkIndex = chunkIndices[i];
    <span class="keywordflow">for</span> (Renderable* r : m_chunks[chunkIndex].renderables)
    {
        r-&gt;setTransform(actor.getPxActor()-&gt;getGlobalPose() * pxAsset.chunks[chunkIndex].convexes[0].transform);
    }
}
</pre></div><p>
In order to use joints set joint create function with <em>ExtPxManager::setCreateJointFunction</em>(...). It will be called when new TkJoint's are being created. All the joint updates and remove will be handled by manager internally.<p>
<br>
 <h2><a class="anchor" name="ExtImpactDamageManager">
ExtImpactDamageManager</a></h2>
<b>Impact Damage Manager</b> - is a reference implementation for fast and easy impact damage support. It's built on top of ExtPxManager.<p>
In order to use it create it:<p>
<div class="fragment"><pre class="fragment">ExtImpactDamageManager* impactManager = ExtImpactDamageManager::create(pxManager);
</pre></div><p>
Call its onContact method on every <em>PxSimulationEventCallback</em> <em>onContact()</em> <p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>EventCallback : <span class="keyword">public</span> PxSimulationEventCallback
{
<span class="keyword">public</span>:
    EventCallback(ExtImpactDamageManager* manager) : m_manager(manager) {}

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onContact(<span class="keyword">const</span> PxContactPairHeader&amp; pairHeader, <span class="keyword">const</span> PxContactPair* pairs, uint32_t nbPairs)
    {
        m_manager-&gt;onContact(pairHeader, pairs, nbPairs);
    }

<span class="keyword">private</span>:
    ExtImpactDamageManager*     m_manager;
};
</pre></div><p>
Call <em>applyDamage()</em> when you want the buffered damage to be applied:<p>
<div class="fragment"><pre class="fragment">impactManager-&gt;applyDamage();
</pre></div><p>
<b>N.B.</b> for impact damage to work, you must enable contact notification with custom the filter shader for PxScene. <em>ExtImpactDamageManager</em> has a reference filter shader implementation which can be used for that:<p>
<div class="fragment"><pre class="fragment">PxSceneDesc sceneDesc;
sceneDesc.filterShader = ExtImpactDamageManager::FilterShader;
</pre></div><p>
<br>
 <h2><a class="anchor" name="extpxstresssolver">
ExtPxStressSolver</a></h2>
<b>Stress Solver</b> - this wrapper class uses <a class="el" href="pageextstress.html">Stress Solver Extension (NvBlastExtStress)</a> to apply stress calculations to an ExtPxFamily. See <a class="el" href="pageextstress.html">Stress Solver Extension (NvBlastExtStress)</a> for the details of the underlying stress solver.<h3><a class="anchor" name="pxstresssolverusage">
Usage</a></h3>
In order to use it, instance an ExtPxStressSolver by providing <em>ExtPxFamily:</em> <p>
<div class="fragment"><pre class="fragment">ExtPxStressSolver* stressSolver = ExtPxStressSolver::create(family);
</pre></div><p>
And then call update() every frame:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> doDamage = <span class="keyword">true</span>; <span class="comment">// if you want to actually apply stress and damage actors</span>
stressSolver-&gt;update(doDamage);
</pre></div><p>
By default it will apply scene gravity on static actors and centrifugal force on dynamic actors.<p>
The underlying ExtStressSolver can be accessed using ExtPxStressSolver::getSolver(). For example, to apply impulse to a particular actor, use applyImpulse(...) can be called for additional stress to apply:<p>
<div class="fragment"><pre class="fragment">stressSolver-&gt;getSolver().addForce(actor, position, impulse);
</pre></div><p>
Finally, the stress solver (and its underlying ExtStressSolver) may be released using<p>
<div class="fragment"><pre class="fragment">stressSolver-&gt;release();
</pre></div><p>
<br>
 <h2><a class="anchor" name="ExtSync">
ExtSync</a></h2>
<b>Synchronization Extension (NvBlastExtSync)</b> - is a reference implementation for synchronizing Blast state.<p>
The idea is that you can use it to write synchronization events to the buffer (on server for example) and then apply this buffer on a client. TkFamily ID should be properly set for that.<p>
3 types of events are supported:<p>
<ul>
<li><b>ExtSyncEventType::Fracture</b>: Fracture event. Contains fracture commands information on particular TkFamily. Applied incrementally. Relatively small.</li><li><b>ExtSyncEventType::FamilySync</b>: Family sync event. Contains all necessary information to fully sync TkFamily state.</li><li><b>ExtSyncEventType::Physics</b>: Physics sync event. Contains all necessary information to fully sync ExtPxFamily state.</li></ul>
<p>
In order to use it create ExtSync:<p>
<div class="fragment"><pre class="fragment">ExtSync* sync = ExtSync::create();
</pre></div><p>
Then let ExtSync insatnce listen to family fracture commands and write them to internal buffer:<p>
<div class="fragment"><pre class="fragment">TkFamily* family = ...;
family-&gt;addListener(*sync);

<span class="comment">// fracture family</span>
<span class="comment">// ....</span>
</pre></div><p>
You can fully record TkFamily state or ExtPxFamily state at any moment by calling:<p>
<div class="fragment"><pre class="fragment">sync-&gt;syncFamily(tkFamily);
<span class="comment">// or</span>
sync-&gt;syncFamily(pxFamily);
</pre></div><p>
Now you can take sync buffer:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> ExtSyncEvent*<span class="keyword">const</span>* buffer;
uint32_t size;
sync-&gt;acquireSyncBuffer(buffer, size);

m_savedBuffer.resize(size);
<span class="keywordflow">for</span> (uint32_t i = 0; i &lt; size; ++i)
{
    m_savedBuffer[i] = buffer[i]-&gt;clone();
}

sync-&gt;releaseSyncBuffer();
</pre></div><p>
On the client you can then apply this buffer:<p>
<div class="fragment"><pre class="fragment">sync-&gt;applySyncBuffer(tkFramework, m_savedBuffer.data(), m_savedBuffer.size(), group, pxManager);
</pre></div><p>
ExtPxManager is required only if sync buffer contains ExtSyncEventType::Physics events.<p>
<br>
 </div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
