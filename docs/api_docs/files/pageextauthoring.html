<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 API Reference: Asset Authoring (NvBlastExtAuthoring)</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="pageextauthoring">Asset Authoring (NvBlastExtAuthoring) </a></h1>The Authoring extension provides tools for creation of a Blast&trade; asset from a provided mesh.<p>
There are four tools for creation of Blast&trade; assets.<p>
<br>
 <h2><a class="anchor" name="fracturetool">
FractureTool</a></h2>
<a class="el" href="class_nv_1_1_blast_1_1_fracture_tool.html">Nv::Blast::FractureTool</a> (see <a class="el" href="_nv_blast_ext_authoring_fracture_tool_8h.html">NvBlastExtAuthoringFractureTool.h</a>) is used to fracture an input mesh. It supports Voronoi fracturing and also simple slicing. Internal surfaces of output chunks can be tesselated and noise can be applied to them. The slicing method supports slicing with a noisy slicing surface, which allows the creation of a jagged slicing line. Noisy slicing is switched on by setting a non-zero noise amplitude in slicing parameters (<a class="el" href="struct_nv_1_1_blast_1_1_slicing_configuration.html">Nv::Blast::SlicingConfiguration</a>).<p>
FractureTool supports two types of output:<p>
1) Array of triangles - the tool fills provided array with triangles of chunk, ID of chunk should be provided.<p>
2) Buffered output - the tool fills provided array with vertices, and another array of arrays with indices. Indices form triplets of vertices of triangle.<p>
<br>
 <h2><a class="anchor" name="convexmeshbuilder">
ConvexMeshBuilder</a></h2>
<a class="el" href="class_nv_1_1_blast_1_1_convex_mesh_builder.html">Nv::Blast::ConvexMeshBuilder</a> is a tool for creation of collision geometry for physics engine. It recieves mesh vertices, and returns the convex hull of those vertices. If creation of a convex hull fails, the tool creates collision geometry as a bounding box of provided vertices.<p>
The tool provides a method to trim convex hulls against each other. It can be used along with noisy slicing to avoid "explosive" behavior due to penetration of neighboring collision hulls into each other. As a drawback, penetration of render meshes into each other is possible due to trimmed collision geometry.<p>
<br>
 <h2><a class="anchor" name="bondgenerator">
BondGenerator</a></h2>
<a class="el" href="class_nv_1_1_blast_1_1_blast_bond_generator.html">Nv::Blast::BlastBondGenerator</a> is a tool for creation of Blast&trade; Bond descriptors from provided geometry data. It has separate a method which is optimized for working FractureTool. <div class="fragment"><pre class="fragment">int32_t <a class="code" href="class_nv_1_1_blast_1_1_blast_bond_generator.html#fbf304132c5600fbe6b4f423ac2e2452">Nv::Blast::BlastBondGenerator::buildDescFromInternalFracture</a>(FractureTool* tool, <span class="keyword">const</span> std::vector&lt;bool&gt;&amp; chunkIsSupport, std::vector&lt;NvBlastBondDesc&gt;&amp; resultBondDescs, std::vector&lt;NvBlastChunkDesc&gt;&amp; resultChunkDescriptors);
</pre></div><p>
Other methods can work with prefractured meshes created in Third party tools, and can be used for converting prefractured models to Blast&trade; assets.<p>
<a class="el" href="class_nv_1_1_blast_1_1_blast_bond_generator.html">Nv::Blast::BlastBondGenerator</a> supports two modes of <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> data generation:<p>
1) Exact - in this mode exact common surface between chunks is found and considered as interface between them. Exact normal, area and centroid are computed.<p>
2) Average - this mode uses approximations of the interface, and can be used for gathering <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> data for assets, where chunks penetrate each other, e.g. chunks with noise.<p>
<br>
 <h2><a class="anchor" name="meshcleaner">
MeshCleaner</a></h2>
<a class="el" href="class_nv_1_1_blast_1_1_mesh_cleaner.html">Nv::Blast::MeshCleaner</a> can be used to remove self intersections and open edges in the interior of a mesh, making it more likely to fracture well.<p>
To use it, create a MeshCleaner using<p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_nv_1_1_blast_1_1_mesh_cleaner.html">Nv::Blast::MeshCleaner</a>* cleaner = <a class="code" href="_nv_blast_ext_authoring_8h.html#a763b10260b7d2a495fb106601977422">NvBlastExtAuthoringCreateMeshCleaner</a>();
</pre></div><p>
Given an <a class="el" href="class_nv_1_1_blast_1_1_mesh.html">Nv::Blast::Mesh</a> called "mesh", simply call<p>
<div class="fragment"><pre class="fragment"><a class="code" href="class_nv_1_1_blast_1_1_mesh.html">Nv::Blast::Mesh</a>* newMesh = cleaner-&gt;<a class="code" href="class_nv_1_1_blast_1_1_mesh_cleaner.html#6681704bd0186e56c55f7b9ba9174d27">cleanMesh</a>(mesh);
</pre></div><p>
If successful, newMesh will be a valid pointer to the cleaned mesh. Otherwise, newMesh will be NULL.<p>
When done, release using <div class="fragment"><pre class="fragment">cleaner-&gt;<a class="code" href="class_nv_1_1_blast_1_1_mesh_cleaner.html#9cb8249f4619e4e1169ae1553d3bdd41">release</a>();
</pre></div><p>
<br>
 </div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
