<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 API Reference: Nv::Blast::TkFramework Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespace_nv.html">Nv</a>::<a class="el" href="namespace_nv_1_1_blast.html">Blast</a>::<a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html">TkFramework</a>
  </div>
<div class="contents">
<h1>Nv::Blast::TkFramework Class Reference</h1><!-- doxytag: class="Nv::Blast::TkFramework" --><code>#include &lt;<a class="el" href="_nv_blast_tk_framework_8h-source.html">NvBlastTkFramework.h</a>&gt;</code>
<p>

<p>
<a href="class_nv_1_1_blast_1_1_tk_framework-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#30b4f2c95a00aa2cd98a3ba4001b0cb8">createActor</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a> &amp;desc)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#9f9ae6a30e80b39d3fcbb14483c20646">createAsset</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *assetLL, <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_joint_desc.html">Nv::Blast::TkAssetJointDesc</a> *jointDescs=nullptr, uint32_t jointDescCount=0, bool ownsAsset=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#f1279d3414ad43036ff3e9e4b37e0a43">createAsset</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a> &amp;desc)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_group.html">TkGroup</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#fbb1cce46ef38bf0a3fb2a5e1b4e2499">createGroup</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a> &amp;desc)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#40b557778256cd6589a3b174015c3029">createJoint</a> (const <a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a> &amp;desc)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#80df575e224678953bd5ae33ac7ab22d">ensureAssetExactSupportCoverage</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#d6f25c2fa686ebe78a612ad657b6745f">findObjectByID</a> (const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;id) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#58225ad807e6aa4c2b54a7ede92fcabf">getObjectCount</a> (const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;type) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#0de2324a24540ad80fff89f808532160">getObjects</a> (<a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> **buffer, uint32_t bufferSize, const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;type, uint32_t indexStart=0) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#c675c056796a68b29fb303b135eab416">getType</a> (<a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html#57681ffd26c84b5272b7e0c23103493a">TkTypeIndex::Enum</a> typeIndex) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#c98d733dfdddbbcfa806b4c282e17aa0">release</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#5a0817a19d4f4c0f715d3a54fe25eadf">reorderAssetDescChunks</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *bondDescs, uint32_t bondCount, uint32_t *chunkReorderMap=nullptr, bool keepBondNormalChunkOrder=false) const =0</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#64d7cfa0510f159444d37408dd1fdf05">~TkFramework</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
BlastTk Framework.<p>
The framework exists as a singleton and is used to create objects, deserialize object streams, and hold references to identified objects (<a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a>, <a class="el" href="class_nv_1_1_blast_1_1_tk_family.html">TkFamily</a>, and <a class="el" href="class_nv_1_1_blast_1_1_tk_group.html">TkGroup</a>) which may be recalled by their GUIDs. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="64d7cfa0510f159444d37408dd1fdf05"></a><!-- doxytag: member="Nv::Blast::TkFramework::~TkFramework" ref="64d7cfa0510f159444d37408dd1fdf05" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Nv::Blast::TkFramework::~TkFramework           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor is virtual and not public - use the <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html#c98d733dfdddbbcfa806b4c282e17aa0">release()</a> method instead of explicitly deleting the <a class="el" href="class_nv_1_1_blast_1_1_tk_framework.html">TkFramework</a> 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="30b4f2c95a00aa2cd98a3ba4001b0cb8"></a><!-- doxytag: member="Nv::Blast::TkFramework::createActor" ref="30b4f2c95a00aa2cd98a3ba4001b0cb8" args="(const TkActorDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a>* Nv::Blast::TkFramework::createActor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an actor from the given descriptor. The actor will be the first member of a new <a class="el" href="class_nv_1_1_blast_1_1_tk_family.html">TkFamily</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The actor descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_actor_desc.html">TkActorDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created actor, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f9ae6a30e80b39d3fcbb14483c20646"></a><!-- doxytag: member="Nv::Blast::TkFramework::createAsset" ref="9f9ae6a30e80b39d3fcbb14483c20646" args="(const NvBlastAsset *assetLL, Nv::Blast::TkAssetJointDesc *jointDescs=nullptr, uint32_t jointDescCount=0, bool ownsAsset=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a>* Nv::Blast::TkFramework::createAsset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>assetLL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_joint_desc.html">Nv::Blast::TkAssetJointDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>jointDescs</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>jointDescCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ownsAsset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an asset from a low-level <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>assetLL</em>&nbsp;</td><td>The low-level <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> to encapsulate. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jointDescs</em>&nbsp;</td><td>Optional joint descriptors to add to the new asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>jointDescCount</em>&nbsp;</td><td>The number of joint descriptors in the jointDescs array. If non-zero, jointDescs cannot be NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ownsAsset</em>&nbsp;</td><td>Does this <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a> own the <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> and thus is responsible for freeing it.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created asset, if memory was available for the operation. Otherwise, returns NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1279d3414ad43036ff3e9e4b37e0a43"></a><!-- doxytag: member="Nv::Blast::TkFramework::createAsset" ref="f1279d3414ad43036ff3e9e4b37e0a43" args="(const TkAssetDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_asset.html">TkAsset</a>* Nv::Blast::TkFramework::createAsset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an asset from the given descriptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The asset descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created asset, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fbb1cce46ef38bf0a3fb2a5e1b4e2499"></a><!-- doxytag: member="Nv::Blast::TkFramework::createGroup" ref="fbb1cce46ef38bf0a3fb2a5e1b4e2499" args="(const TkGroupDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_group.html">TkGroup</a>* Nv::Blast::TkFramework::createGroup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a group from the given descriptor. A group is a processing unit, to which the user may add TkActors. New actors generated from splitting a <a class="el" href="class_nv_1_1_blast_1_1_tk_actor.html">TkActor</a> are automatically put into the same group. However, any actor may be removed from its group and optionally placed into another group, or left groupless.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The group descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_group_desc.html">TkGroupDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created group, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="40b557778256cd6589a3b174015c3029"></a><!-- doxytag: member="Nv::Blast::TkFramework::createJoint" ref="40b557778256cd6589a3b174015c3029" args="(const TkJointDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_joint.html">TkJoint</a>* Nv::Blast::TkFramework::createJoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a joint from the given descriptor. The following restrictions apply:<p>
Only one joint may be created between any two support chunks.<p>
A joint cannot be created between chunks within the same actor using this method. See <a class="el" href="struct_nv_1_1_blast_1_1_tk_asset_desc.html">TkAssetDesc</a> for a description of bond joint flags, which will create internal joints within an actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The joint descriptor (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_joint_desc.html">TkJointDesc</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created joint, if the descriptor was valid and memory was available for the operation. Otherwise, returns NULL. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80df575e224678953bd5ae33ac7ab22d"></a><!-- doxytag: member="Nv::Blast::TkFramework::ensureAssetExactSupportCoverage" ref="80df575e224678953bd5ae33ac7ab22d" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Nv::Blast::TkFramework::ensureAssetExactSupportCoverage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function to ensure (check and update) support coverage of chunks, required for asset creation via the createAsset function.<p>
This is a convenience wrapper for the low-level NvBlastEnsureAssetExactSupportCoverage function.<p>
The chunk descriptors may have their support flags be modified to ensure exact coverage.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>An array of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The size of the chunkDescs array.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff coverage was already exact. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6f25c2fa686ebe78a612ad657b6745f"></a><!-- doxytag: member="Nv::Blast::TkFramework::findObjectByID" ref="d6f25c2fa686ebe78a612ad657b6745f" args="(const NvBlastID &amp;id) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a>* Nv::Blast::TkFramework::findObjectByID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>id</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up an object derived from <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> by its ID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the object to look up (see <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer the object if it exists, NULL otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="58225ad807e6aa4c2b54a7ede92fcabf"></a><!-- doxytag: member="Nv::Blast::TkFramework::getObjectCount" ref="58225ad807e6aa4c2b54a7ede92fcabf" args="(const TkType &amp;type) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t Nv::Blast::TkFramework::getObjectCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of TkIdentifiable-derived objects in the framework of the given type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type object for the given type.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of objects that currently exist of the given type. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0de2324a24540ad80fff89f808532160"></a><!-- doxytag: member="Nv::Blast::TkFramework::getObjects" ref="0de2324a24540ad80fff89f808532160" args="(TkIdentifiable **buffer, uint32_t bufferSize, const TkType &amp;type, uint32_t indexStart=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t Nv::Blast::TkFramework::getObjects           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>indexStart</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve an array of pointers (into the user-supplied buffer) to TkIdentifiable-derived objects of the given type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>A user-supplied array of <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of elements available to write into buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The type object for the given type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>indexStart</em>&nbsp;</td><td>The starting index of the object.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of <a class="el" href="class_nv_1_1_blast_1_1_tk_identifiable.html">TkIdentifiable</a> pointers written to the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c675c056796a68b29fb303b135eab416"></a><!-- doxytag: member="Nv::Blast::TkFramework::getType" ref="c675c056796a68b29fb303b135eab416" args="(TkTypeIndex::Enum typeIndex) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_nv_1_1_blast_1_1_tk_type.html">TkType</a>* Nv::Blast::TkFramework::getType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html#57681ffd26c84b5272b7e0c23103493a">TkTypeIndex::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>typeIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To find the type information for a given TkIdentifiable-derived class, use this funtion with the <a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html#57681ffd26c84b5272b7e0c23103493a">TkTypeIndex::Enum</a> corresponding to the desired class name.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeIndex</em>&nbsp;</td><td>Enumerated object type (see <a class="el" href="struct_nv_1_1_blast_1_1_tk_type_index.html">TkTypeIndex</a>).</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>type object associated with the object's class. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c98d733dfdddbbcfa806b4c282e17aa0"></a><!-- doxytag: member="Nv::Blast::TkFramework::release" ref="c98d733dfdddbbcfa806b4c282e17aa0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Nv::Blast::TkFramework::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release this framework and all contained objects. Global singleton is set to NULL. 
</div>
</div><p>
<a class="anchor" name="5a0817a19d4f4c0f715d3a54fe25eadf"></a><!-- doxytag: member="Nv::Blast::TkFramework::reorderAssetDescChunks" ref="5a0817a19d4f4c0f715d3a54fe25eadf" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, NvBlastBondDesc *bondDescs, uint32_t bondCount, uint32_t *chunkReorderMap=nullptr, bool keepBondNormalChunkOrder=false) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Nv::Blast::TkFramework::reorderAssetDescChunks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>bondDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bondCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkReorderMap</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keepBondNormalChunkOrder</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Helper function to build and apply chunk reorder map, so that chunk descriptors are properly ordered for the createAsset function.<p>
This is a convenience wrapper for the low-level NvBlastReorderAssetDescChunks function.<p>
This function may modify both the chunkDescs and bondDescs array, since rearranging chunk descriptors requires re-indexing within the bond descriptors.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td><a class="el" href="struct_nv_1_1_blast_1_1_array.html">Array</a> of chunk descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondDescs</em>&nbsp;</td><td><a class="el" href="struct_nv_1_1_blast_1_1_array.html">Array</a> of bond descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondCount</em>&nbsp;</td><td>The number of bond descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkReorderMap</em>&nbsp;</td><td>If not NULL, must be a pointer to a uint32_t array of size desc.chunkCount. Maps old chunk indices to the reordered chunk indices. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keepBondNormalChunkOrder</em>&nbsp;</td><td>If true, bond normals will be flipped if their chunk index order was reveresed by the reorder map.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the chunks did not require reordering (chunkReorderMap is the identity map). </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>sdk/toolkit/include/<a class="el" href="_nv_blast_tk_framework_8h-source.html">NvBlastTkFramework.h</a></ul>
</div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
