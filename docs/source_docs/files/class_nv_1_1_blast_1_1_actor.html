<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 Source Reference: Nv::Blast::Actor Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>User's&nbsp;Guide</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespace_nv.html">Nv</a>::<a class="el" href="namespace_nv_1_1_blast.html">Blast</a>::<a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a>
  </div>
</div>
<div class="contents">
<h1>Nv::Blast::Actor Class Reference</h1><!-- doxytag: class="Nv::Blast::Actor" --><!-- doxytag: inherits="NvBlastActor" --><code>#include &lt;<a class="el" href="_nv_blast_actor_8h-source.html">NvBlastActor.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Nv::Blast::Actor:</div>
<div class="dynsection">

<p><center><img src="class_nv_1_1_blast_1_1_actor.png" usemap="#Nv::Blast::Actor_map" border="0" alt=""></center>
<map name="Nv::Blast::Actor_map">
<area href="struct_nv_blast_actor.html" alt="NvBlastActor" shape="rect" coords="0,0,98,24">
</map>
</div>

<p>
<a href="class_nv_1_1_blast_1_1_actor-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor_1_1_graph_node_it.html">GraphNodeIt</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor_1_1_visible_chunk_it.html">VisibleChunkIt</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#49fd726e45168bd756e564cfaac6e356">Actor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#cc3bf3a166faa14d058d8ef505228221">applyFracture</a> (<a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *eventBuffers, const <a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *commands, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn, <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#29a56cd7e2849b62dc7d8cf532f38d81">damageBond</a> (const <a class="el" href="struct_nv_blast_bond_fracture_data.html">NvBlastBondFractureData</a> &amp;cmd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#f4c1927ea77f5812e8a3fed84b0b4e25">damageBond</a> (uint32_t nodeIndex0, uint32_t nodeIndex1, uint32_t bondIndex, float healthDamage)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#7ae51f1cdc7a63ab67823d7cd08552d2">damageBond</a> (uint32_t nodeIndex0, uint32_t nodeIndex1, float healthDamage)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#372818aee680b0cefdcd27010234826e">findIslands</a> (void *scratch)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#6a49c4fb6e6999f6e46f34baaf771a0d">generateFracture</a> (<a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *commandBuffers, const <a class="el" href="struct_nv_blast_damage_program.html">NvBlastDamageProgram</a> &amp;program, const void *programParams, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn, <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_nv_1_1_blast_1_1_asset.html">Asset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#01efe9a7ce4758228ff7fbfc18439e89">getAsset</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#fbfed518265059f7d0ea6601636c6ed5">getBondHealths</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#9ddc5add20e934c2ec460b88ecb6556a">getBonds</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#ca8326bdc2871657619eeafc807d1457">getChunks</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_nv_1_1_blast_1_1_family_graph.html">FamilyGraph</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#429db395668307ba22fde4c5e2682ec8">getFamilyGraph</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_nv_1_1_blast_1_1_family_header.html">FamilyHeader</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#ca8517524822b8a5033e95779260412b">getFamilyHeader</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#dfb84f684de7a4ea8fe3d1f5e64c3de5">getFirstGraphNodeIndex</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#002024d15f89fb12d7fdf87ca9cba554">getFirstSubsupportChunkIndex</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#b6aee8dec9462c3ca4e6ab7c88d50527">getFirstVisibleChunkIndex</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="struct_nv_1_1_blast_1_1_support_graph.html">SupportGraph</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#c99a48ba8fc03c3e44d4cdb13612bc54">getGraph</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#6f9d68ce898e4107fd936d7c1e9dd921">getGraphNodeCount</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const uint32_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#d5767f4ad545fe41f5287fc5b906957d">getGraphNodeIndexLinks</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#b329eb40c508c1a1709257c5d0d89c80">getIndex</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#cffc5390424f427cedbdfc5016aa7c95">getLeafChunkCount</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#7945bc8bf80130d18f8cc4ffdd70b6c3">getLowerSupportChunkHealths</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#765a28ec7411bba2569bfcb59e12924e">getSubsupportChunkHealths</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#b0603f4160ed95129a3236cf946a0857">getVisibleChunkCount</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#3d8f539000a51c21e4fd610b504a3bf6">isActive</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#c3ffff9a1718f2cb453725cda4259a8d">isBoundToWorld</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#25972224f087f241f35ffeef6fca0681">isSingleSupportChunk</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#57d6da1ace2c16bbd3d85a09a1f05ed6">isSplitRequired</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#c4d1080a2df5ddafe54f1aa9afef6e40">isSubSupportChunk</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#4f9e6d8c9f2b31644ae0a4bb03f88309">partition</a> (<a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> **newActors, uint32_t newActorsSize, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#eac2e1cee03f101305013770cf0dff46">partitionMultipleGraphNodes</a> (<a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> **newActors, uint32_t newActorsSize, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#e75f198c241b12842e68e10e34e8ac39">partitionSingleLowerSupportChunk</a> (<a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> **newActors, uint32_t newActorsSize, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#d8552a04fa6cdb1f3a01d11d18209e5a">release</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#969be9f4dd3f7e96cc710f5116511a36">serializationRequiredStorage</a> (<a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#c760ce0295329d39567e57a10fc6a1fe">serialize</a> (void *buffer, uint32_t bufferSize, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#ecab306397e048f4f46440d4879ba879">split</a> (<a class="el" href="struct_nv_blast_actor_split_event.html">NvBlastActorSplitEvent</a> *result, uint32_t newActorsMaxCount, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn, <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#6b9c6155e42a10f77ea5addc2ccbdcc4">splitRequiredScratch</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#d4a77624d52d337f1b7158f0be6c233f">updateVisibleChunksFromGraphNodes</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#307ec3c8c73cb706ec153bd63baee7c4">create</a> (<a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, const <a class="el" href="struct_nv_blast_actor_desc.html">NvBlastActorDesc</a> *desc, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#3082322754cba457f678e567b288fe02">createRequiredScratch</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#cc84f6ae1ee76cf23b15898d2ba23721">deserialize</a> (<a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, const void *buffer, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#e80652887c7949e9bf5692fa06a1efa6">FamilyHeader</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_nv_1_1_blast_1_1_actor.html#530bf5c4f1c9ca4b2766218b88290d9a">updateVisibleChunksFromSupportChunk</a> (<a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> *, <a class="el" href="struct_nv_1_1_blast_1_1_index_d_link.html">IndexDLink</a>&lt; uint32_t &gt; *, uint32_t *, uint32_t, uint32_t, const <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> *, uint32_t)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Internal implementation of solver actor.<p>
These objects are stored within the family in a single array. A pointer to a <a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> class will be given to the user through the <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> opaque type. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="49fd726e45168bd756e564cfaac6e356"></a><!-- doxytag: member="Nv::Blast::Actor::Actor" ref="49fd726e45168bd756e564cfaac6e356" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Nv::Blast::Actor::Actor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cc3bf3a166faa14d058d8ef505228221"></a><!-- doxytag: member="Nv::Blast::Actor::applyFracture" ref="cc3bf3a166faa14d058d8ef505228221" args="(NvBlastFractureBuffers *eventBuffers, const NvBlastFractureBuffers *commands, NvBlastLog logFn, NvBlastTimers *timers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::Actor::applyFracture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *&nbsp;</td>
          <td class="paramname"> <em>eventBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *&nbsp;</td>
          <td class="paramname"> <em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See NvBlastActorApplyFracture 
</div>
</div><p>
<a class="anchor" name="307ec3c8c73cb706ec153bd63baee7c4"></a><!-- doxytag: member="Nv::Blast::Actor::create" ref="307ec3c8c73cb706ec153bd63baee7c4" args="(NvBlastFamily *family, const NvBlastActorDesc *desc, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a>* Nv::Blast::Actor::create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor_desc.html">NvBlastActorDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an actor from a descriptor (creates a family). This actor will represent an unfractured instance of the asset. The asset must be in a valid state, for example each chunk hierarchy in it must contain at least one support chunk (a single support chunk in a hierarchy corresponds to the root chunk). This will always be the case for assets created by NvBlastCreateAsset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>Family in which to create a new actor. The family must be valid and have no other actors in it. (See createFamily.) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td><a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> initialization data, must be a valid pointer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch memory of size createRequiredScratch(desc) bytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new actor if the input is valid (by the conditions described above), NULL otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3082322754cba457f678e567b288fe02"></a><!-- doxytag: member="Nv::Blast::Actor::createRequiredScratch" ref="3082322754cba457f678e567b288fe02" args="(const NvBlastFamily *family)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Nv::Blast::Actor::createRequiredScratch           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the size of the scratch space (in bytes) required to be passed into the create function, based upon the family that will be passed to the create function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family being instanced.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes required. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29a56cd7e2849b62dc7d8cf532f38d81"></a><!-- doxytag: member="Nv::Blast::Actor::damageBond" ref="29a56cd7e2849b62dc7d8cf532f38d81" args="(const NvBlastBondFractureData &amp;cmd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::damageBond           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_bond_fracture_data.html">NvBlastBondFractureData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cmd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TODO: document 
</div>
</div><p>
<a class="anchor" name="f4c1927ea77f5812e8a3fed84b0b4e25"></a><!-- doxytag: member="Nv::Blast::Actor::damageBond" ref="f4c1927ea77f5812e8a3fed84b0b4e25" args="(uint32_t nodeIndex0, uint32_t nodeIndex1, uint32_t bondIndex, float healthDamage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::Actor::damageBond           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nodeIndex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nodeIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bondIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>healthDamage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TODO: document 
</div>
</div><p>
<a class="anchor" name="7ae51f1cdc7a63ab67823d7cd08552d2"></a><!-- doxytag: member="Nv::Blast::Actor::damageBond" ref="7ae51f1cdc7a63ab67823d7cd08552d2" args="(uint32_t nodeIndex0, uint32_t nodeIndex1, float healthDamage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::damageBond           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nodeIndex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>nodeIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>healthDamage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Damage bond between two chunks by health amount (instance graph also will be notified in case bond is broken after). 
</div>
</div><p>
<a class="anchor" name="cc84f6ae1ee76cf23b15898d2ba23721"></a><!-- doxytag: member="Nv::Blast::Actor::deserialize" ref="cc84f6ae1ee76cf23b15898d2ba23721" args="(NvBlastFamily *family, const void *buffer, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a>* Nv::Blast::Actor::deserialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserialize a single <a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> from a buffer. An actor family must given, into which the actor will be inserted if it is compatible. That is, it must not share any chunks or internal IDs with the actors already present in the block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>Family in which to deserialize the actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>Buffer containing the serialized actor data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the deserialized actor if successful, NULL otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="372818aee680b0cefdcd27010234826e"></a><!-- doxytag: member="Nv::Blast::Actor::findIslands" ref="372818aee680b0cefdcd27010234826e" args="(void *scratch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::findIslands           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform islands search. Bonds which are broken when their health values drop to zero (or below) may lead to new islands of chunks which need to be split into new actors. This function labels all nodes in the instance graph (see <a class="el" href="class_nv_1_1_blast_1_1_family_graph.html">FamilyGraph</a>) with a unique index per island that may be used as actor indices for new islands.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch memory of size <a class="el" href="class_nv_1_1_blast_1_1_actor.html#6b9c6155e42a10f77ea5addc2ccbdcc4">splitRequiredScratch()</a>.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of new islands found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a49c4fb6e6999f6e46f34baaf771a0d"></a><!-- doxytag: member="Nv::Blast::Actor::generateFracture" ref="6a49c4fb6e6999f6e46f34baaf771a0d" args="(NvBlastFractureBuffers *commandBuffers, const NvBlastDamageProgram &amp;program, const void *programParams, NvBlastLog logFn, NvBlastTimers *timers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::Actor::generateFracture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *&nbsp;</td>
          <td class="paramname"> <em>commandBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_damage_program.html">NvBlastDamageProgram</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>programParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See NvBlastActorGenerateFracture 
</div>
</div><p>
<a class="anchor" name="01efe9a7ce4758228ff7fbfc18439e89"></a><!-- doxytag: member="Nv::Blast::Actor::getAsset" ref="01efe9a7ce4758228ff7fbfc18439e89" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE const <a class="el" href="class_nv_1_1_blast_1_1_asset.html">Asset</a> * Nv::Blast::Actor::getAsset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility to get the asset this actor is associated with, through its family.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the asset associated with this actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fbfed518265059f7d0ea6601636c6ed5"></a><!-- doxytag: member="Nv::Blast::Actor::getBondHealths" ref="fbfed518265059f7d0ea6601636c6ed5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE float * Nv::Blast::Actor::getBondHealths           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bond health for the interfaces between two chunks, of type float. Since the bond is shared by two chunks, the same bond health is used for chunk[i] -&gt; chunk[j] as for chunk[j] -&gt; chunk[i].<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the array of healths associated with all bonds in the support graph. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ddc5add20e934c2ec460b88ecb6556a"></a><!-- doxytag: member="Nv::Blast::Actor::getBonds" ref="9ddc5add20e934c2ec460b88ecb6556a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> * Nv::Blast::Actor::getBonds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the bonds, of type <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an array of size m_bondCount. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca8326bdc2871657619eeafc807d1457"></a><!-- doxytag: member="Nv::Blast::Actor::getChunks" ref="ca8326bdc2871657619eeafc807d1457" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> * Nv::Blast::Actor::getChunks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the chunks, of type <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an array of size m_chunkCount. </dd></dl>

</div>
</div><p>
<a class="anchor" name="429db395668307ba22fde4c5e2682ec8"></a><!-- doxytag: member="Nv::Blast::Actor::getFamilyGraph" ref="429db395668307ba22fde4c5e2682ec8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE <a class="el" href="class_nv_1_1_blast_1_1_family_graph.html">FamilyGraph</a> * Nv::Blast::Actor::getFamilyGraph           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the instance graph for islands searching.<p>
Return the dynamic data generated for the support graph. (See <a class="el" href="class_nv_1_1_blast_1_1_family_graph.html">FamilyGraph</a>.) This is used to store current connectivity information based upon bond and chunk healths, as well as cached intermediate data for faster incremental updates. 
</div>
</div><p>
<a class="anchor" name="ca8517524822b8a5033e95779260412b"></a><!-- doxytag: member="Nv::Blast::Actor::getFamilyHeader" ref="ca8517524822b8a5033e95779260412b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE <a class="el" href="struct_nv_1_1_blast_1_1_family_header.html">FamilyHeader</a> * Nv::Blast::Actor::getFamilyHeader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the family (see <a class="el" href="struct_nv_1_1_blast_1_1_family_header.html">FamilyHeader</a>) that this actor belongs to.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the <a class="el" href="struct_nv_1_1_blast_1_1_family_header.html">FamilyHeader</a> for this actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dfb84f684de7a4ea8fe3d1f5e64c3de5"></a><!-- doxytag: member="Nv::Blast::Actor::getFirstGraphNodeIndex" ref="dfb84f684de7a4ea8fe3d1f5e64c3de5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getFirstGraphNodeIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to graph node linked list for this actor. The index returned is that of a link in the FamilyHeader's <a class="el" href="class_nv_1_1_blast_1_1_actor.html#d5767f4ad545fe41f5287fc5b906957d">getGraphNodeIndexLinks()</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the head of the graph node linked list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="002024d15f89fb12d7fdf87ca9cba554"></a><!-- doxytag: member="Nv::Blast::Actor::getFirstSubsupportChunkIndex" ref="002024d15f89fb12d7fdf87ca9cba554" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getFirstSubsupportChunkIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the index of the first subsupport chunk.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the first subsupport chunk. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6aee8dec9462c3ca4e6ab7c88d50527"></a><!-- doxytag: member="Nv::Blast::Actor::getFirstVisibleChunkIndex" ref="b6aee8dec9462c3ca4e6ab7c88d50527" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getFirstVisibleChunkIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to visible chunk linked list for this actor. The index returned is that of a link in the FamilyHeader's getVisibleChunkIndexLinks().<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of the head of the visible chunk linked list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c99a48ba8fc03c3e44d4cdb13612bc54"></a><!-- doxytag: member="Nv::Blast::Actor::getGraph" ref="c99a48ba8fc03c3e44d4cdb13612bc54" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE const <a class="el" href="struct_nv_1_1_blast_1_1_support_graph.html">SupportGraph</a> * Nv::Blast::Actor::getGraph           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the support graph.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the support graph associated with this actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f9d68ce898e4107fd936d7c1e9dd921"></a><!-- doxytag: member="Nv::Blast::Actor::getGraphNodeCount" ref="6f9d68ce898e4107fd936d7c1e9dd921" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getGraphNodeCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of graph nodes, corresponding to support chunks, for this actor. See also getFirstGraphNodeIndex.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of graph nodes in the actor's graph node index list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d5767f4ad545fe41f5287fc5b906957d"></a><!-- doxytag: member="Nv::Blast::Actor::getGraphNodeIndexLinks" ref="d5767f4ad545fe41f5287fc5b906957d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE const uint32_t * Nv::Blast::Actor::getGraphNodeIndexLinks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Graph node index links, of type uint32_t. The successor to index[i] is m_graphNodeIndexLinksOffset[i]. A value of <a class="el" href="namespace_nv_1_1_blast.html#c1fa2bac8c635169faa133e5de246da9">invalidIndex&lt;uint32_t&gt;()</a> indicates no successor.<p>
getGraphNodeIndexLinks returns an array of size m_asset-&gt;m_graphNodeCount. 
</div>
</div><p>
<a class="anchor" name="b329eb40c508c1a1709257c5d0d89c80"></a><!-- doxytag: member="Nv::Blast::Actor::getIndex" ref="b329eb40c508c1a1709257c5d0d89c80" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Utility to calculate actor index.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the index of this actor in the FamilyHeader's getActors() array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cffc5390424f427cedbdfc5016aa7c95"></a><!-- doxytag: member="Nv::Blast::Actor::getLeafChunkCount" ref="cffc5390424f427cedbdfc5016aa7c95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getLeafChunkCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of leaf chunks for this actor.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of leaf chunks for this actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7945bc8bf80130d18f8cc4ffdd70b6c3"></a><!-- doxytag: member="Nv::Blast::Actor::getLowerSupportChunkHealths" ref="7945bc8bf80130d18f8cc4ffdd70b6c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE float * Nv::Blast::Actor::getLowerSupportChunkHealths           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the health for each support chunk and subsupport chunk, of type float.<p>
Use <a class="el" href="class_nv_1_1_blast_1_1_actor.html#01efe9a7ce4758228ff7fbfc18439e89">getAsset()</a>-&gt;getContiguousLowerSupportIndex() to map lower-support chunk indices into the range of indices valid for this array.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a float array of chunk healths. </dd></dl>

</div>
</div><p>
<a class="anchor" name="765a28ec7411bba2569bfcb59e12924e"></a><!-- doxytag: member="Nv::Blast::Actor::getSubsupportChunkHealths" ref="765a28ec7411bba2569bfcb59e12924e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE float * Nv::Blast::Actor::getSubsupportChunkHealths           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to the start of the subsupport chunk health array.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the array of health values associated with all descendants of support chunks. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0603f4160ed95129a3236cf946a0857"></a><!-- doxytag: member="Nv::Blast::Actor::getVisibleChunkCount" ref="b0603f4160ed95129a3236cf946a0857" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::getVisibleChunkCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of visible chunks. This is calculated from <a class="el" href="class_nv_1_1_blast_1_1_actor.html#d4a77624d52d337f1b7158f0be6c233f">updateVisibleChunksFromGraphNodes()</a>. See also getFirstVisibleChunkIndex.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of chunks in the actor's visible chunk index list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d8f539000a51c21e4fd610b504a3bf6"></a><!-- doxytag: member="Nv::Blast::Actor::isActive" ref="3d8f539000a51c21e4fd610b504a3bf6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::Actor::isActive           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Since this object is not deleted (unless the family is deleted), we use m_familyOffset to determine if the actor is valid, or "active." When no actors in an instance return <a class="el" href="class_nv_1_1_blast_1_1_actor.html#3d8f539000a51c21e4fd610b504a3bf6">isActive()</a>, it should be safe to delete the family.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff this actor is valid for use (active). </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3ffff9a1718f2cb453725cda4259a8d"></a><!-- doxytag: member="Nv::Blast::Actor::isBoundToWorld" ref="c3ffff9a1718f2cb453725cda4259a8d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::Actor::isBoundToWorld           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff this actor contains the "world" support graph node, created when a bond contains the <a class="el" href="namespace_nv_1_1_blast.html#c1fa2bac8c635169faa133e5de246da9">invalidIndex&lt;uint32_t&gt;()</a> value for one of their chunkIndices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="25972224f087f241f35ffeef6fca0681"></a><!-- doxytag: member="Nv::Blast::Actor::isSingleSupportChunk" ref="25972224f087f241f35ffeef6fca0681" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::Actor::isSingleSupportChunk           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not this actor represents a single support chunk. If the actor contains a single support chunk, it can have no other chunks associated with it.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff this actor contains exactly one support chunk. </dd></dl>

</div>
</div><p>
<a class="anchor" name="57d6da1ace2c16bbd3d85a09a1f05ed6"></a><!-- doxytag: member="Nv::Blast::Actor::isSplitRequired" ref="57d6da1ace2c16bbd3d85a09a1f05ed6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::Actor::isSplitRequired           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff this actor was damaged and <a class="el" href="class_nv_1_1_blast_1_1_actor.html#ecab306397e048f4f46440d4879ba879">split()</a> call is required. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4d1080a2df5ddafe54f1aa9afef6e40"></a><!-- doxytag: member="Nv::Blast::Actor::isSubSupportChunk" ref="c4d1080a2df5ddafe54f1aa9afef6e40" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::Actor::isSubSupportChunk           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether or not this actor represents a subsupport chunk. If the actor contains a subsupport chunk, then it can have only that chunk.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff this actor contains a chunk which is a descendant of a support chunk. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f9e6d8c9f2b31644ae0a4bb03f88309"></a><!-- doxytag: member="Nv::Blast::Actor::partition" ref="4f9e6d8c9f2b31644ae0a4bb03f88309" args="(Actor **newActors, uint32_t newActorsSize, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE uint32_t Nv::Blast::Actor::partition           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> **&nbsp;</td>
          <td class="paramname"> <em>newActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newActorsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Partition this actor into smaller pieces.<p>
If this actor represents a single support or subsupport chunk, then after this operation this actor will released if child chunks are created (see Return value), and its pointer no longer valid for use (unless it appears in the newActors list).<p>
This function will not split a leaf chunk actor. In that case, the actor is not destroyed and this function returns 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActors</em>&nbsp;</td><td>user-supplied array of actor pointers to hold the actors generated from this partitioning. This array must be of size equal to the number of leaf chunks in the asset, to guarantee that all actors are reported. (See AssetDataHeader::m_leafChunkCount.) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActorsSize</em>&nbsp;</td><td>The size of the user-supplied newActors array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of new actors created. If greater than newActorsSize, some actors are not reported in the newActors array. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eac2e1cee03f101305013770cf0dff46"></a><!-- doxytag: member="Nv::Blast::Actor::partitionMultipleGraphNodes" ref="eac2e1cee03f101305013770cf0dff46" args="(Actor **newActors, uint32_t newActorsSize, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::partitionMultipleGraphNodes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> **&nbsp;</td>
          <td class="paramname"> <em>newActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newActorsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Partition this actor into smaller pieces. Use this function if this actor contains more than one support chunk.<p>
After this operation, if successful, this actor will released, and its pointer no longer valid for use (unless it appears in the newActors list).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActors</em>&nbsp;</td><td>User-supplied array of actor pointers to hold the actors generated from this partitioning. Note: this actor will not be released, but will hold a subset of the graph nodes that it had before the function was called. This array must be of size equal to the number of graph nodes in the asset, to guarantee that all actors are reported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActorsSize</em>&nbsp;</td><td>The size of the user-supplied newActors array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of new actors created. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e75f198c241b12842e68e10e34e8ac39"></a><!-- doxytag: member="Nv::Blast::Actor::partitionSingleLowerSupportChunk" ref="e75f198c241b12842e68e10e34e8ac39" args="(Actor **newActors, uint32_t newActorsSize, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::partitionSingleLowerSupportChunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> **&nbsp;</td>
          <td class="paramname"> <em>newActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newActorsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Partition this actor into smaller pieces if it is a single lower-support chunk actor. Use this function on single support or sub-support chunks.<p>
After this operation, if successful (child chunks created, see Return value), this actor will released, and its pointer no longer valid for use.<p>
This function will not split a leaf chunk actor. In that case, the actor is not destroyed and this function returns 0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActors</em>&nbsp;</td><td>User-supplied array of actor pointers to hold the actors generated from this partitioning. Note: this actor will be released. This array must be of size equal to the lower-support chunk's child count, to guarantee that all actors are reported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActorsSize</em>&nbsp;</td><td>The size of the user-supplied newActors array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of new actors created. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d8552a04fa6cdb1f3a01d11d18209e5a"></a><!-- doxytag: member="Nv::Blast::Actor::release" ref="d8552a04fa6cdb1f3a01d11d18209e5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NV_INLINE bool Nv::Blast::Actor::release           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release this actor's association with a family, if any. This actor should be considered deleted after this function is called.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if release was successful (actor was active). </dd></dl>

</div>
</div><p>
<a class="anchor" name="969be9f4dd3f7e96cc710f5116511a36"></a><!-- doxytag: member="Nv::Blast::Actor::serializationRequiredStorage" ref="969be9f4dd3f7e96cc710f5116511a36" args="(NvBlastLog logFn) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::serializationRequiredStorage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the space required to serialize this actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the required buffer size in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c760ce0295329d39567e57a10fc6a1fe"></a><!-- doxytag: member="Nv::Blast::Actor::serialize" ref="c760ce0295329d39567e57a10fc6a1fe" args="(void *buffer, uint32_t bufferSize, NvBlastLog logFn) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::serialize           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialize actor into single-actor buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>User-supplied buffer, must be at least of size given by NvBlastActorGetSerializationSize(actor). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The size of the user-supplied buffer. The buffer size must be less than 4GB. If NvBlastActorGetSerializationSize(actor) &gt;= 4GB, this actor cannot be serialized with this method. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written to the buffer, or 0 if there is an error (such as an under-sized buffer). </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecab306397e048f4f46440d4879ba879"></a><!-- doxytag: member="Nv::Blast::Actor::split" ref="ecab306397e048f4f46440d4879ba879" args="(NvBlastActorSplitEvent *result, uint32_t newActorsMaxCount, void *scratch, NvBlastLog logFn, NvBlastTimers *timers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Nv::Blast::Actor::split           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_actor_split_event.html">NvBlastActorSplitEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newActorsMaxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
See NvBlastActorSplit 
</div>
</div><p>
<a class="anchor" name="6b9c6155e42a10f77ea5addc2ccbdcc4"></a><!-- doxytag: member="Nv::Blast::Actor::splitRequiredScratch" ref="6b9c6155e42a10f77ea5addc2ccbdcc4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Nv::Blast::Actor::splitRequiredScratch           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The scratch space required to call the findIslands function, or the split function, in bytes.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes required. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4a77624d52d337f1b7158f0be6c233f"></a><!-- doxytag: member="Nv::Blast::Actor::updateVisibleChunksFromGraphNodes" ref="d4a77624d52d337f1b7158f0be6c233f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nv::Blast::Actor::updateVisibleChunksFromGraphNodes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recalculate the visible chunk list for this actor based upon it graph node list (does not modify subsupport chunk actors) 
</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="e80652887c7949e9bf5692fa06a1efa6"></a><!-- doxytag: member="Nv::Blast::Actor::FamilyHeader" ref="e80652887c7949e9bf5692fa06a1efa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="struct_nv_1_1_blast_1_1_family_header.html">FamilyHeader</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="530bf5c4f1c9ca4b2766218b88290d9a"></a><!-- doxytag: member="Nv::Blast::Actor::updateVisibleChunksFromSupportChunk" ref="530bf5c4f1c9ca4b2766218b88290d9a" args="(Actor *, IndexDLink&lt; uint32_t &gt; *, uint32_t *, uint32_t, uint32_t, const NvBlastChunk *, uint32_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void updateVisibleChunksFromSupportChunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_nv_1_1_blast_1_1_actor.html">Actor</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_1_1_blast_1_1_index_d_link.html">IndexDLink</a>&lt; uint32_t &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>sdk/lowlevel/source/<a class="el" href="_nv_blast_actor_8h-source.html">NvBlastActor.h</a></ul>
</div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
