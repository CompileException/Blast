<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 Source Reference: sdk/extensions/authoring/source/NvBlastExtAuthoringVSA.h Source File</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>User's&nbsp;Guide</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>sdk/extensions/authoring/source/NvBlastExtAuthoringVSA.h</h1><a href="_nv_blast_ext_authoring_v_s_a_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This code contains NVIDIA Confidential Information and is disclosed to you</span>
<a name="l00002"></a>00002 <span class="comment">// under a form of NVIDIA software license agreement provided separately to you.</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Notice</span>
<a name="l00005"></a>00005 <span class="comment">// NVIDIA Corporation and its licensors retain all intellectual property and</span>
<a name="l00006"></a>00006 <span class="comment">// proprietary rights in and to this software and related documentation and</span>
<a name="l00007"></a>00007 <span class="comment">// any modifications thereto. Any use, reproduction, disclosure, or</span>
<a name="l00008"></a>00008 <span class="comment">// distribution of this software and related documentation without an express</span>
<a name="l00009"></a>00009 <span class="comment">// license agreement from NVIDIA Corporation is strictly prohibited.</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES</span>
<a name="l00012"></a>00012 <span class="comment">// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO</span>
<a name="l00013"></a>00013 <span class="comment">// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,</span>
<a name="l00014"></a>00014 <span class="comment">// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// Information and code furnished is believed to be accurate and reliable.</span>
<a name="l00017"></a>00017 <span class="comment">// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such</span>
<a name="l00018"></a>00018 <span class="comment">// information or for any infringement of patents or other rights of third parties that may</span>
<a name="l00019"></a>00019 <span class="comment">// result from its use. No license is granted by implication or otherwise under any patent</span>
<a name="l00020"></a>00020 <span class="comment">// or patent rights of NVIDIA Corporation. Details are subject to change without notice.</span>
<a name="l00021"></a>00021 <span class="comment">// This code supersedes and replaces all information previously supplied.</span>
<a name="l00022"></a>00022 <span class="comment">// NVIDIA Corporation products are not authorized for use as critical</span>
<a name="l00023"></a>00023 <span class="comment">// components in life support devices or systems without express written approval of</span>
<a name="l00024"></a>00024 <span class="comment">// NVIDIA Corporation.</span>
<a name="l00025"></a>00025 <span class="comment">//</span>
<a name="l00026"></a>00026 <span class="comment">// Copyright (c) 2016-2017 NVIDIA Corporation. All rights reserved.</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef NVBLASTEXTAUTHORINGVSA_H</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#define NVBLASTEXTAUTHORINGVSA_H</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="keyword">namespace </span>Nv
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034 <span class="keyword">namespace </span>Blast
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">/*</span>
<a name="l00038"></a>00038 <span class="comment">    This code copied from APEX GSA</span>
<a name="l00039"></a>00039 <span class="comment">*/</span>
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html">00041</a> <span class="keyword">namespace </span>VSA
<a name="l00042"></a>00042 {
<a name="l00043"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">00043</a> <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>;
<a name="l00044"></a>00044 
<a name="l00045"></a><a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_v_s3_d___halfspace___set.html">00045</a> <span class="keyword">struct </span><a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_v_s3_d___halfspace___set.html">VS3D_Halfspace_Set</a>
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047     <span class="keyword">virtual</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>    <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_v_s3_d___halfspace___set.html#3a38d067e70fffca879b6d7139952652">farthest_halfspace</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> plane[4], <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> point[4]) = 0;
<a name="l00048"></a>00048 };
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="comment">// Simple types and operations for internal calculations</span>
<a name="l00052"></a><a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">00052</a> <span class="keyword">struct </span><a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> { <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>, <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>; };  <span class="comment">// 3-vector </span>
<a name="l00053"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">00053</a> <span class="keyword">inline</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="bt_vector3_8h.html#0d05bb202a57e1c47ae0eeeec2502c1b" title="Return the x value.">x</a>, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="bt_vector3_8h.html#88617d2888b444b2ad2384b17b0eeadf" title="Return the y value.">y</a>, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="bt_vector3_8h.html#49dd8d4770be4de32dd57f9b926aa396" title="Return the z value.">z</a>) { <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> r; r.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a> = x; r.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a> = y; r.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a> = z; <span class="keywordflow">return</span> r; }   <span class="comment">// vector builder</span>
<a name="l00054"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d2ed66762db3fe1f41d35fa6b46df1ee">00054</a> <span class="keyword">inline</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d2ed66762db3fe1f41d35fa6b46df1ee">operator +	</a>(<span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; a, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; b) { <span class="keywordflow">return</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a> + b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a> + b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>, a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a> + b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>); }         <span class="comment">// vector addition</span>
<a name="l00055"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#207654189a89fba3d6256779afcd41d1">00055</a> <span class="keyword">inline</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#207654189a89fba3d6256779afcd41d1">operator *	</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> s, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; v) { <span class="keywordflow">return</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(s*v.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, s*v.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>, s*v.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>); }                <span class="comment">// scalar multiplication</span>
<a name="l00056"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d74b41a40540aa0ea4de7600bac6f552">00056</a> <span class="keyword">inline</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d74b41a40540aa0ea4de7600bac6f552">operator |	</a>(<span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; a, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; b) { <span class="keywordflow">return</span> a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a> + a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a> + a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>; }               <span class="comment">// dot product</span>
<a name="l00057"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#38ae2e49308ac2b5c9285edaf237c976">00057</a> <span class="keyword">inline</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#38ae2e49308ac2b5c9285edaf237c976">operator ^	</a>(<span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; a, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; b) { <span class="keywordflow">return</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a> - b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>*a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>, a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a> - b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>*a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a> - b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>*a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>); } <span class="comment">// cross product</span>
<a name="l00058"></a>00058 
<a name="l00059"></a><a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">00059</a> <span class="keyword">struct </span><a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a> { <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>; <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a>; };    <span class="comment">// 4-vector split into 3-vector and scalar parts</span>
<a name="l00060"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">00060</a> <span class="keyword">inline</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>(<span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; v, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="bt_vector3_8h.html#c0e6714ccdb1e845d1c5cc79c057331a" title="Return the w value.">w</a>) { <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a> r; r.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a> = v; r.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a> = w; <span class="keywordflow">return</span> r; } <span class="comment">// vector builder</span>
<a name="l00061"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#87683b078798507378729b21dd4aa0da">00061</a> <span class="keyword">inline</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d74b41a40540aa0ea4de7600bac6f552">operator | </a>(<span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a>&amp; a, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a>&amp; b) { <span class="keywordflow">return</span> (a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a> | b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>) + a.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a>*b.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a>; }         <span class="comment">// dot product</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">// More accurate perpendicular</span>
<a name="l00064"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#31a9155136d1363434a70a3d9005c581">00064</a> <span class="keyword">inline</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#31a9155136d1363434a70a3d9005c581">perp</a>(<span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; a, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; b)
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066     <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a> c = a^b;   <span class="comment">// Cross-product gives perpendicular</span>
<a name="l00067"></a>00067 <span class="preprocessor">#if VS3D_HIGH_ACCURACY || REAL_DOUBLE</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> c2 = c | c;
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (c2 != 0) c = c + (1 / c2)*((a | c)*(c^b) + (b | c)*(a^c));  <span class="comment">// Improvement to (a b)^T(c) = (0)</span>
<a name="l00070"></a>00070 <span class="preprocessor">#endif</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>    <span class="keywordflow">return</span> c;
<a name="l00072"></a>00072 }
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">// Square</span>
<a name="l00075"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e7c36beab73d66e43e7fcaf72309f65e">00075</a> <span class="keyword">inline</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e7c36beab73d66e43e7fcaf72309f65e">sq</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> <a class="code" href="bt_vector3_8h.html#0d05bb202a57e1c47ae0eeeec2502c1b" title="Return the x value.">x</a>) { <span class="keywordflow">return</span> x*x; }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">// Returns index of the extremal element in a three-element set {e0, e1, e2} based upon comparisons c_ij. The extremal index m is such that c_mn is true, or e_m == e_n, for all n.</span>
<a name="l00078"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#cc5d2bf37685bfd6e8763d559d144880">00078</a> <span class="keyword">inline</span> <span class="keywordtype">int</span>  <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#cc5d2bf37685bfd6e8763d559d144880">ext_index</a>(<span class="keywordtype">int</span> c_10, <span class="keywordtype">int</span> c_21, <span class="keywordtype">int</span> c_20) { <span class="keywordflow">return</span> c_10 &lt;&lt; c_21 | (c_21&amp;c_20) &lt;&lt; 1; }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="comment">// Returns index (0, 1, or 2) of minimum argument</span>
<a name="l00081"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#c40d9e7d67ea46fd503fc1001174256c">00081</a> <span class="keyword">inline</span> <span class="keywordtype">int</span>  <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#c40d9e7d67ea46fd503fc1001174256c">index_of_min</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x0, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x1, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x2) { <span class="keywordflow">return</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#cc5d2bf37685bfd6e8763d559d144880">ext_index</a>((<span class="keywordtype">int</span>)(x1 &lt; x0), (<span class="keywordtype">int</span>)(x2 &lt; x1), (<span class="keywordtype">int</span>)(x2 &lt; x0)); }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment">// Compare fractions with positive deominators.  Returns a_num*sqrt(a_rden2) &gt; b_num*sqrt(b_rden2)</span>
<a name="l00084"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">00084</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">frac_gt</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> a_num, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> a_rden2, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> b_num, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> b_rden2)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086     <span class="keyword">const</span> <span class="keywordtype">bool</span> a_num_neg = a_num &lt; 0;
<a name="l00087"></a>00087     <span class="keyword">const</span> <span class="keywordtype">bool</span> b_num_neg = b_num &lt; 0;
<a name="l00088"></a>00088     <span class="keywordflow">return</span> a_num_neg != b_num_neg ? b_num_neg : ((a_num*a_num*a_rden2 &gt; b_num*b_num*b_rden2) != a_num_neg);
<a name="l00089"></a>00089 }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="comment">// Returns index (0, 1, or 2) of maximum fraction with positive deominators</span>
<a name="l00092"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#a4cd5beecd9202dfd1b9440aca332ae9">00092</a> <span class="keyword">inline</span> <span class="keywordtype">int</span>  <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#a4cd5beecd9202dfd1b9440aca332ae9">index_of_max_frac</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x0_num, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x0_rden2, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x1_num, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x1_rden2, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x2_num, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> x2_rden2)
<a name="l00093"></a>00093 {
<a name="l00094"></a>00094     <span class="keywordflow">return</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#cc5d2bf37685bfd6e8763d559d144880">ext_index</a>((<span class="keywordtype">int</span>)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">frac_gt</a>(x1_num, x1_rden2, x0_num, x0_rden2), (<span class="keywordtype">int</span>)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">frac_gt</a>(x2_num, x2_rden2, x1_num, x1_rden2), (<span class="keywordtype">int</span>)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">frac_gt</a>(x2_num, x2_rden2, x0_num, x0_rden2));
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">// Compare values given their signs and squares.  Returns a &gt; b.  a2 and b2 may have any constant offset applied to them.</span>
<a name="l00098"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#b202062acbefba5fac638d3caf7b8b15">00098</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#b202062acbefba5fac638d3caf7b8b15">sgn_sq_gt</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sgn_a, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> a2, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sgn_b, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> b2) { <span class="keywordflow">return</span> sgn_a*sgn_b &lt; 0 ? (sgn_b &lt; 0) : ((a2 &gt; b2) != (sgn_a &lt; 0)); }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">// Returns index (0, 1, or 2) of maximum value given their signs and squares.  sq_x0, sq_x1, and sq_x2 may have any constant offset applied to them.</span>
<a name="l00101"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d99de32f12e7fcd534d856e7c7daf094">00101</a> <span class="keyword">inline</span> <span class="keywordtype">int</span>  <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d99de32f12e7fcd534d856e7c7daf094">index_of_max_sgn_sq</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sgn_x0, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sq_x0, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sgn_x1, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sq_x1, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sgn_x2, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> sq_x2)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103     <span class="keywordflow">return</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#cc5d2bf37685bfd6e8763d559d144880">ext_index</a>((<span class="keywordtype">int</span>)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#b202062acbefba5fac638d3caf7b8b15">sgn_sq_gt</a>(sgn_x1, sq_x1, sgn_x0, sq_x0), (<span class="keywordtype">int</span>)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#b202062acbefba5fac638d3caf7b8b15">sgn_sq_gt</a>(sgn_x2, sq_x2, sgn_x1, sq_x1), (<span class="keywordtype">int</span>)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#b202062acbefba5fac638d3caf7b8b15">sgn_sq_gt</a>(sgn_x2, sq_x2, sgn_x0, sq_x0));
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">// Project 2D (homogeneous) vector onto 2D half-space boundary</span>
<a name="l00107"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#42e36ee6745a0051b19817e9d33ed91e">00107</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#42e36ee6745a0051b19817e9d33ed91e">project2D</a>(<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; r, <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html">Vec3</a>&amp; plane, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> delta, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> recip_n2, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> eps2)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109     r = r + (-delta*recip_n2)*<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>, 0);
<a name="l00110"></a>00110     r = r + (-(r | plane)*recip_n2)*<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>, 0);  <span class="comment">// Second projection for increased accuracy</span>
<a name="l00111"></a>00111     <span class="keywordflow">if</span> ((r | r) &gt; eps2) <span class="keywordflow">return</span>;
<a name="l00112"></a>00112     r = (-plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a>*recip_n2)*<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#a1a733303a2cf444b2feca0659e6baf0">y</a>, 0);
<a name="l00113"></a>00113     r.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#d0c0d42fa98073907e15bfee206cd098">z</a> = 1;
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="comment">// Update function for vs3d_test</span>
<a name="l00118"></a>00118 <span class="keyword">static</span> <span class="keywordtype">bool</span> vs3d_update(Vec4&amp; p, Vec4 S[4], <span class="keywordtype">int</span>&amp; plane_count, <span class="keyword">const</span> Vec4&amp; q, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> eps2)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120     <span class="comment">// h plane is the last plane</span>
<a name="l00121"></a>00121     <span class="keyword">const</span> Vec4&amp; h = S[plane_count - 1];
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">// Handle plane_count == 1 specially (optimization; this could be commented out)</span>
<a name="l00124"></a>00124     <span class="keywordflow">if</span> (plane_count == 1)
<a name="l00125"></a>00125     {
<a name="l00126"></a>00126         <span class="comment">// Solution is objective projected onto h plane</span>
<a name="l00127"></a>00127         p = q;
<a name="l00128"></a>00128         p.v = p.v + -(p | h)*h.v;
<a name="l00129"></a>00129         if ((p | p) &lt;= eps2) p = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>(-h.w*h.v, 1); <span class="comment">// If p == 0 then q is a direction vector, any point in h is a support point</span>
<a name="l00130"></a>00130         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     <span class="comment">// Create basis in the h plane</span>
<a name="l00134"></a>00134     <span class="keyword">const</span> <span class="keywordtype">int</span> min_i = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#c40d9e7d67ea46fd503fc1001174256c">index_of_min</a>(h.v.x*h.v.x, h.v.y*h.v.y, h.v.z*h.v.z);
<a name="l00135"></a>00135     <span class="keyword">const</span> Vec3 <a class="code" href="bt_vector3_8h.html#88617d2888b444b2ad2384b17b0eeadf" title="Return the y value.">y</a> = h.v^<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>((<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>)(min_i == 0), (<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>)(min_i == 1), (<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>)(min_i == 2));
<a name="l00136"></a>00136     <span class="keyword">const</span> Vec3 <a class="code" href="bt_vector3_8h.html#0d05bb202a57e1c47ae0eeeec2502c1b" title="Return the x value.">x</a> = y^h.v;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="comment">// Use reduced vector r instead of p</span>
<a name="l00139"></a>00139     Vec3 r = { x | q.v, y | q.v, q.w*(y | y) }; <span class="comment">// (x|x) = (y|y) = square of plane basis scale</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     <span class="comment">// If r == 0 (within epsilon), then it is a direction vector, and we have a bounded solution</span>
<a name="l00142"></a>00142     <span class="keywordflow">if</span> ((r | r) &lt;= eps2) r.z = 1;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="comment">// Create plane equations in the h plane.  These will not be normalized in general.</span>
<a name="l00145"></a>00145     <span class="keywordtype">int</span> N = 0;          <span class="comment">// Plane count in h subspace</span>
<a name="l00146"></a>00146     Vec3 R[3];          <span class="comment">// Planes in h subspace</span>
<a name="l00147"></a>00147     <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> recip_n2[3];   <span class="comment">// Plane normal vector reciprocal lengths squared</span>
<a name="l00148"></a>00148     <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> delta[3];      <span class="comment">// Signed distance of objective to the planes</span>
<a name="l00149"></a>00149     <span class="keywordtype">int</span> index[3];       <span class="comment">// Keep track of original plane indices</span>
<a name="l00150"></a>00150     for (<span class="keywordtype">int</span> i = 0; i &lt; plane_count - 1; ++i)
<a name="l00151"></a>00151     {
<a name="l00152"></a>00152         <span class="keyword">const</span> Vec3&amp; vi = S[i].v;
<a name="l00153"></a>00153         <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> cos_theta = h.v | vi;
<a name="l00154"></a>00154         R[N] = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(x | vi, y | vi, S[i].<a class="code" href="bt_vector3_8h.html#c0e6714ccdb1e845d1c5cc79c057331a" title="Return the w value.">w</a> - h.w*cos_theta);
<a name="l00155"></a>00155         index[N] = i;
<a name="l00156"></a>00156         <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> n2 = R[N].x*R[N].x + R[N].y*R[N].y;
<a name="l00157"></a>00157         <span class="keywordflow">if</span> (n2 &gt;= eps2)
<a name="l00158"></a>00158         {
<a name="l00159"></a>00159             <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> lin_norm = (<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>)1.5 - (<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>)0.5*n2; <span class="comment">// 1st-order approximation to 1/sqrt(n2) expanded about n2 = 1</span>
<a name="l00160"></a>00160             R[N] = lin_norm*R[N];   <span class="comment">// We don't need normalized plane equations, but rescaling (even with an approximate normalization) gives better numerical behavior</span>
<a name="l00161"></a>00161             recip_n2[N] = 1 / (R[N].x*R[N].x + R[N].y*R[N].y);
<a name="l00162"></a>00162             delta[N] = r | R[N];
<a name="l00163"></a>00163             ++N;    <span class="comment">// Keep this plane</span>
<a name="l00164"></a>00164         }
<a name="l00165"></a>00165         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cos_theta &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// Parallel cases are redundant and rejected, anti-parallel cases are 1D voids</span>
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     <span class="comment">// Now work with the N-sized R array of half-spaces in the h plane</span>
<a name="l00169"></a>00169     <span class="keywordflow">switch</span> (N)
<a name="l00170"></a>00170     {
<a name="l00171"></a>00171     <span class="keywordflow">case</span> 1: one_plane :
<a name="l00172"></a>00172         <span class="keywordflow">if</span> (delta[0] &lt; 0) N = 0;    <span class="comment">// S[0] is redundant, eliminate it</span>
<a name="l00173"></a>00173         <span class="keywordflow">else</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#42e36ee6745a0051b19817e9d33ed91e">project2D</a>(r, R[0], delta[0], recip_n2[0], eps2);
<a name="l00174"></a>00174         <span class="keywordflow">break</span>;
<a name="l00175"></a>00175     <span class="keywordflow">case</span> 2: two_planes :
<a name="l00176"></a>00176         <span class="keywordflow">if</span> (delta[0] &lt; 0 &amp;&amp; delta[1] &lt; 0) N = 0;    <span class="comment">// S[0] and S[1] are redundant, eliminate them</span>
<a name="l00177"></a>00177         <span class="keywordflow">else</span>
<a name="l00178"></a>00178         {
<a name="l00179"></a>00179             <span class="keyword">const</span> <span class="keywordtype">int</span> max_d_index = (int)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">frac_gt</a>(delta[1], recip_n2[1], delta[0], recip_n2[0]);
<a name="l00180"></a>00180             <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#42e36ee6745a0051b19817e9d33ed91e">project2D</a>(r, R[max_d_index], delta[max_d_index], recip_n2[max_d_index], eps2);
<a name="l00181"></a>00181             <span class="keyword">const</span> <span class="keywordtype">int</span> min_d_index = max_d_index ^ 1;
<a name="l00182"></a>00182             <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> new_delta_min = r | R[min_d_index];
<a name="l00183"></a>00183             <span class="keywordflow">if</span> (new_delta_min &lt; 0)
<a name="l00184"></a>00184             {
<a name="l00185"></a>00185                 index[0] = index[max_d_index];
<a name="l00186"></a>00186                 N = 1;  <span class="comment">// S[min_d_index] is redundant, eliminate it</span>
<a name="l00187"></a>00187             }
<a name="l00188"></a>00188             <span class="keywordflow">else</span>
<a name="l00189"></a>00189             {
<a name="l00190"></a>00190                 <span class="comment">// Set r to the intersection of R[0] and R[1] and keep both</span>
<a name="l00191"></a>00191                 r = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#31a9155136d1363434a70a3d9005c581">perp</a>(R[0], R[1]);
<a name="l00192"></a>00192                 <span class="keywordflow">if</span> (r.z*r.z*recip_n2[0] * recip_n2[1] &lt; eps2)
<a name="l00193"></a>00193                 {
<a name="l00194"></a>00194                     <span class="keywordflow">if</span> (R[0].x*R[1].x + R[0].y*R[1].y &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;    <span class="comment">// 2D void found</span>
<a name="l00195"></a>00195                     <span class="keywordflow">goto</span> one_plane;
<a name="l00196"></a>00196                 }
<a name="l00197"></a>00197                 r = (1 / r.z)*r;    <span class="comment">// We could just as well multiply r by sgn(r.z); we just need to ensure r.z &gt; 0</span>
<a name="l00198"></a>00198             }
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200         <span class="keywordflow">break</span>;
<a name="l00201"></a>00201     <span class="keywordflow">case</span> 3:
<a name="l00202"></a>00202         <span class="keywordflow">if</span> (delta[0] &lt; 0 &amp;&amp; delta[1] &lt; 0 &amp;&amp; delta[2] &lt; 0) N = 0;    <span class="comment">// S[0], S[1], and S[2] are redundant, eliminate them</span>
<a name="l00203"></a>00203         <span class="keywordflow">else</span>
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205             <span class="keyword">const</span> Vec3 row_x = { R[0].x, R[1].x, R[2].x };
<a name="l00206"></a>00206             <span class="keyword">const</span> Vec3 row_y = { R[0].y, R[1].y, R[2].y };
<a name="l00207"></a>00207             <span class="keyword">const</span> Vec3 row_w = { R[0].z, R[1].z, R[2].z };
<a name="l00208"></a>00208             <span class="keyword">const</span> Vec3 cof_w = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#31a9155136d1363434a70a3d9005c581">perp</a>(row_x, row_y);
<a name="l00209"></a>00209             <span class="keyword">const</span> <span class="keywordtype">bool</span> detR_pos = (row_w | cof_w) &gt; 0;
<a name="l00210"></a>00210             <span class="keyword">const</span> <span class="keywordtype">int</span> nrw_sgn0 = cof_w.x*cof_w.x*recip_n2[1] * recip_n2[2] &lt; eps2 ? 0 : (((int)((cof_w.x &gt; 0) == detR_pos) &lt;&lt; 1) - 1);
<a name="l00211"></a>00211             <span class="keyword">const</span> <span class="keywordtype">int</span> nrw_sgn1 = cof_w.y*cof_w.y*recip_n2[2] * recip_n2[0] &lt; eps2 ? 0 : (((int)((cof_w.y &gt; 0) == detR_pos) &lt;&lt; 1) - 1);
<a name="l00212"></a>00212             <span class="keyword">const</span> <span class="keywordtype">int</span> nrw_sgn2 = cof_w.z*cof_w.z*recip_n2[0] * recip_n2[1] &lt; eps2 ? 0 : (((int)((cof_w.z &gt; 0) == detR_pos) &lt;&lt; 1) - 1);
<a name="l00213"></a>00213 
<a name="l00214"></a>00214             <span class="keywordflow">if</span> ((nrw_sgn0 | nrw_sgn1 | nrw_sgn2) &gt;= 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;    <span class="comment">// 3D void found</span>
<a name="l00215"></a>00215 
<a name="l00216"></a>00216             <span class="keyword">const</span> <span class="keywordtype">int</span> positive_width_count = ((nrw_sgn0 &gt;&gt; 1) &amp; 1) + ((nrw_sgn1 &gt;&gt; 1) &amp; 1) + ((nrw_sgn2 &gt;&gt; 1) &amp; 1);
<a name="l00217"></a>00217             <span class="keywordflow">if</span> (positive_width_count == 1)
<a name="l00218"></a>00218             {
<a name="l00219"></a>00219                 <span class="comment">// A single positive width results from a redundant plane.  Eliminate it and peform N = 2 calculation.</span>
<a name="l00220"></a>00220                 <span class="keyword">const</span> <span class="keywordtype">int</span> pos_width_index = ((nrw_sgn1 &gt;&gt; 1) &amp; 1) | (nrw_sgn2 &amp; 2); <span class="comment">// Calculates which index corresponds to the positive-width side</span>
<a name="l00221"></a>00221                 R[pos_width_index] = R[2];
<a name="l00222"></a>00222                 recip_n2[pos_width_index] = recip_n2[2];
<a name="l00223"></a>00223                 delta[pos_width_index] = delta[2];
<a name="l00224"></a>00224                 index[pos_width_index] = index[2];
<a name="l00225"></a>00225                 N = 2;
<a name="l00226"></a>00226                 <span class="keywordflow">goto</span> two_planes;
<a name="l00227"></a>00227             }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229             <span class="comment">// Find the max dot product of r and R[i]/|R_normal[i]|.  For numerical accuracy when the angle between r and the i^{th} plane normal is small, we take some care below:</span>
<a name="l00230"></a>00230             <span class="keyword">const</span> <span class="keywordtype">int</span> max_d_index = r.z != 0
<a name="l00231"></a>00231                 ? <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#a4cd5beecd9202dfd1b9440aca332ae9">index_of_max_frac</a>(delta[0], recip_n2[0], delta[1], recip_n2[1], delta[2], recip_n2[2])    <span class="comment">// displacement term resolves small-angle ambiguity, just use dot product</span>
<a name="l00232"></a>00232                 : <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#d99de32f12e7fcd534d856e7c7daf094">index_of_max_sgn_sq</a>(delta[0], -<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e7c36beab73d66e43e7fcaf72309f65e">sq</a>(r.x*R[0].y - r.y*R[0].x)*recip_n2[0], delta[1], -<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e7c36beab73d66e43e7fcaf72309f65e">sq</a>(r.x*R[1].y - r.y*R[1].x)*recip_n2[1], delta[2], -<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e7c36beab73d66e43e7fcaf72309f65e">sq</a>(r.x*R[2].y - r.y*R[2].x)*recip_n2[2]);  <span class="comment">// No displacement term.  Use wedge product to find the sine of the angle.</span>
<a name="l00233"></a>00233 
<a name="l00234"></a>00234             <span class="comment">// Project r onto max-d plane</span>
<a name="l00235"></a>00235             <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#42e36ee6745a0051b19817e9d33ed91e">project2D</a>(r, R[max_d_index], delta[max_d_index], recip_n2[max_d_index], eps2);
<a name="l00236"></a>00236             N = 1;  <span class="comment">// Unless we use a vertex in the loop below</span>
<a name="l00237"></a>00237             <span class="keyword">const</span> <span class="keywordtype">int</span> index_max = index[max_d_index];
<a name="l00238"></a>00238 
<a name="l00239"></a>00239             <span class="comment">// The number of finite widths should be &gt;= 2.  If not, it should be 0, but in any case it implies three parallel lines in the plane, which we should not have here.</span>
<a name="l00240"></a>00240             <span class="comment">// If we do have three parallel lines (# of finite widths &lt; 2), we've picked the line corresponding to the half-plane farthest from r, which is correct.</span>
<a name="l00241"></a>00241             <span class="keyword">const</span> <span class="keywordtype">int</span> finite_width_count = (nrw_sgn0 &amp; 1) + (nrw_sgn1 &amp; 1) + (nrw_sgn2 &amp; 1);
<a name="l00242"></a>00242             <span class="keywordflow">if</span> (finite_width_count &gt;= 2)
<a name="l00243"></a>00243             {
<a name="l00244"></a>00244                 <span class="keyword">const</span> <span class="keywordtype">int</span> i_remaining[2] = { (1 &lt;&lt; max_d_index) &amp; 3, (3 &gt;&gt; max_d_index) ^ 1 };  <span class="comment">// = {(max_d_index+1)%3, (max_d_index+2)%3}</span>
<a name="l00245"></a>00245                 <span class="keyword">const</span> <span class="keywordtype">int</span> i_select = (int)<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#5d0eb514919e6254be7fd4c428fb156d">frac_gt</a>(delta[i_remaining[1]], recip_n2[i_remaining[1]], delta[i_remaining[0]], recip_n2[i_remaining[0]]);    <span class="comment">// Select the greater of the remaining dot products</span>
<a name="l00246"></a>00246                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i)
<a name="l00247"></a>00247                 {
<a name="l00248"></a>00248                     <span class="keyword">const</span> <span class="keywordtype">int</span> j = i_remaining[i_select^i];  <span class="comment">// i = 0 =&gt; the next-greatest, i = 1 =&gt; the least</span>
<a name="l00249"></a>00249                     <span class="keywordflow">if</span> ((r | R[j]) &gt;= 0)
<a name="l00250"></a>00250                     {
<a name="l00251"></a>00251                         r = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#31a9155136d1363434a70a3d9005c581">perp</a>(R[max_d_index], R[j]);
<a name="l00252"></a>00252                         r = (1 / r.z)*r;    <span class="comment">// We could just as well multiply r by sgn(r.z); we just need to ensure r.z &gt; 0</span>
<a name="l00253"></a>00253                         index[1] = index[j];
<a name="l00254"></a>00254                         N = 2;
<a name="l00255"></a>00255                         <span class="keywordflow">break</span>;
<a name="l00256"></a>00256                     }
<a name="l00257"></a>00257                 }
<a name="l00258"></a>00258             }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260             index[0] = index_max;
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262         <span class="keywordflow">break</span>;
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="comment">// Transform r back to 3D space</span>
<a name="l00266"></a>00266     p = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>(r.x*x + r.y*y + (-r.z*h.w)*h.v, r.z);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="comment">// Pack S array with kept planes</span>
<a name="l00269"></a>00269     <span class="keywordflow">if</span> (N &lt; 2 || index[1] != 0) { <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; ++i) S[i] = S[index[i]]; } <span class="comment">// Safe to copy columns in order</span>
<a name="l00270"></a>00270     <span class="keywordflow">else</span> { <span class="keyword">const</span> Vec4 temp = S[0]; S[0] = S[index[0]]; S[1] = temp; }   <span class="comment">// Otherwise use temp storage to avoid overwrite</span>
<a name="l00271"></a>00271     S[N] = h;
<a name="l00272"></a>00272     plane_count = N + 1;
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="comment">// Performs the VS algorithm for D = 3</span>
<a name="l00279"></a><a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#c6a01ae68f18ecfe9d275f375997e3b9">00279</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#c6a01ae68f18ecfe9d275f375997e3b9">vs3d_test</a>(<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_v_s3_d___halfspace___set.html">VS3D_Halfspace_Set</a>&amp; halfspace_set, <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>* q = <span class="keyword">nullptr</span>)
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281     <span class="comment">// Objective = q if it is not NULL, otherwise it is the origin represented in homogeneous coordinates</span>
<a name="l00282"></a>00282     <span class="keyword">const</span> <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a> objective = q ? (q[3] != 0 ? <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>((1 / q[3])*<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(q[0], q[1], q[2]), 1) : *(<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a>*)q) : <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#78881c15732472ced3ab2e77bc11dfc2">vec3</a>(0, 0, 0), 1);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     <span class="comment">// Tolerance for 3D void simplex algorithm</span>
<a name="l00285"></a>00285     <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> eps_f = (<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>)1 / (<span class="keyword">sizeof</span>(<a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a>) == 4 ? (1L &lt;&lt; 23) : (1LL &lt;&lt; 52));    <span class="comment">// Floating-point epsilon</span>
<a name="l00286"></a>00286 <span class="preprocessor">#if VS3D_HIGH_ACCURACY || REAL_DOUBLE</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> eps = 8 * eps_f;
<a name="l00288"></a>00288 <span class="preprocessor">#else</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> eps = 80 * eps_f;
<a name="l00290"></a>00290 <span class="preprocessor">#endif</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>    <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> eps2 = eps*eps;  <span class="comment">// Using epsilon squared</span>
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <span class="comment">// Maximum allowed iterations of main loop.  If exceeded, error code is returned</span>
<a name="l00294"></a>00294     <span class="keyword">const</span> <span class="keywordtype">int</span> max_iteration_count = 50;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296     <span class="comment">// State</span>
<a name="l00297"></a>00297     <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a> S[4];              <span class="comment">// Up to 4 planes</span>
<a name="l00298"></a>00298     <span class="keywordtype">int</span> plane_count = 0;    <span class="comment">// Number of valid planes</span>
<a name="l00299"></a>00299     <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a> p = objective;     <span class="comment">// Test point, initialized to objective</span>
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     <span class="comment">// Default result, changed to valid result if found in loop below</span>
<a name="l00302"></a>00302     <span class="keywordtype">int</span> result = -1;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     <span class="comment">// Iterate until a stopping condition is met or the maximum number of iterations is reached</span>
<a name="l00305"></a>00305     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; result &lt; 0 &amp;&amp; i &lt; max_iteration_count; ++i)
<a name="l00306"></a>00306     {
<a name="l00307"></a>00307         <a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a>&amp; plane = S[plane_count++];
<a name="l00308"></a>00308         <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> delta = halfspace_set.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_v_s3_d___halfspace___set.html#3a38d067e70fffca879b6d7139952652">farthest_halfspace</a>(&amp;plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>, &amp;p.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec3.html#e335cbbcb1b1a657b4e42feb54a413ae">x</a>);
<a name="l00309"></a>00309 <span class="preprocessor">#if VS3D_UNNORMALIZED_PLANE_HANDLING != 0</span>
<a name="l00310"></a>00310 <span class="preprocessor"></span>        <span class="keyword">const</span> <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#17168752dfdb7c7b455d54f98d7f87d6">real</a> recip_norm = vs3d_recip_sqrt(plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a> | plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>);
<a name="l00311"></a>00311         plane = <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>(recip_norm*plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>, recip_norm*plane.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a>);
<a name="l00312"></a>00312         delta *= recip_norm;
<a name="l00313"></a>00313 <span class="preprocessor">#endif</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (delta &lt;= 0 || delta*delta &lt;= eps2*(p | p)) result = 1;  <span class="comment">// Intersection found</span>
<a name="l00315"></a>00315         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!vs3d_update(p, S, plane_count, objective, eps2)) result = 0;  <span class="comment">// Void simplex found</span>
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     <span class="comment">// If q is given, fill it with the solution (normalize p.w if it is not zero)</span>
<a name="l00319"></a>00319     <span class="keywordflow">if</span> (q) *(<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html">Vec4</a>*)q = (p.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a> != 0) ? <a class="code" href="namespace_nv_1_1_blast_1_1_v_s_a.html#e9cc9edbccb4fe70660e16546bf7bb82">vec4</a>((1 / p.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#a03b64741c5ebccd33323c19a278da2c">w</a>)*p.<a class="code" href="struct_nv_1_1_blast_1_1_v_s_a_1_1_vec4.html#1c361f283cb854916057ab8fcbe85062">v</a>, 1) : p;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     <span class="keywordflow">return</span> result;
<a name="l00322"></a>00322 }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 } <span class="comment">// namespace VSA</span>
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 } <span class="comment">// namespace Blast</span>
<a name="l00327"></a>00327 } <span class="comment">// namespace Nv</span>
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 <span class="preprocessor">#endif // ifndef NVBLASTEXTAUTHORINGVSA_H</span>
</pre></div></div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
