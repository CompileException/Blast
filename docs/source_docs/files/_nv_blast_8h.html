<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 Source Reference: sdk/lowlevel/include/NvBlast.h File Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>User's&nbsp;Guide</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sdk/lowlevel/include/NvBlast.h File Reference</h1><code>#include &quot;<a class="el" href="_nv_blast_types_8h-source.html">NvBlastTypes.h</a>&quot;</code><br>

<p>
<a href="_nv_blast_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#88efac48b308c27be2742ed601bcb32f">NvBlastActorApplyFracture</a> (<a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *eventBuffers, <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, const <a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *commands, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn, <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#20bf7daebbc3804766c32fd6bd624a07">NvBlastActorCanFracture</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#befb2480ab1985d6fed58583050d57d2">NvBlastActorGenerateFracture</a> (<a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *commandBuffers, const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, const <a class="el" href="struct_nv_blast_damage_program.html">NvBlastDamageProgram</a> program, const void *programParams, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn, <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#95a908aa7b6e14e1ed881bf3cfe810d6">NvBlastActorGetMaxActorCountForSplit</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#66450acf095adeadc70d2a478c9ab2d1">NvBlastActorGetRequiredScratchForSplit</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#dd7f66f53ab03e71eeeebaee7dec12b2">NvBlastActorIsBoundToWorld</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#8b330a0a7b654dfaa0c35f4c396a781e">NvBlastActorIsSplitRequired</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#ccc0bb617daadd4554cb2224559a4dfc">NvBlastActorSplit</a> (<a class="el" href="struct_nv_blast_actor_split_event.html">NvBlastActorSplitEvent</a> *result, <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, uint32_t newActorsMaxCount, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn, <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#2293c45fd57fbe7cb448a849151907cf">NvBlastActorDeactivate</a> (<a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API const float *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#9d01e16dc02bed206adef7fcbf5935f0">NvBlastActorGetBondHealths</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#245ad453eda4f0102b5617f4edff9b66">NvBlastActorGetFamily</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#ec37b629f83ac2586e9edeb78f825e5c">NvBlastActorGetGraphNodeCount</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#8c68e7844b84555aa74fa950d57469f1">NvBlastActorGetGraphNodeIndices</a> (uint32_t *graphNodeIndices, uint32_t graphNodeIndicesSize, const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#0b985e47f17306b7457a995fb1fc77cc">NvBlastActorGetIndex</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#32618a9eaafe25af758e4ffa33f36603">NvBlastActorGetSerializationSize</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#b103c80c01c2a4baeece9316bfcfc140">NvBlastActorGetVisibleChunkCount</a> (const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#f04e1c60f327da97f1fbbc41e8c618f9">NvBlastActorGetVisibleChunkIndices</a> (uint32_t *visibleChunkIndices, uint32_t visibleChunkIndicesSize, const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#da0d2f72c83e2c2357ba8e93e5a3986e">NvBlastActorSerialize</a> (void *buffer, uint32_t bufferSize, const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *actor, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#cd731f119f9107a644167a14209c03f3">NvBlastApplyAssetDescChunkReorderMap</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *reorderedChunkDescs, const <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *bondDescs, uint32_t bondCount, const uint32_t *chunkReorderMap, bool keepBondNormalChunkOrder, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#94fd6269d5b3142d4035ae7e049b96b0">NvBlastApplyAssetDescChunkReorderMapInPlace</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *bondDescs, uint32_t bondCount, const uint32_t *chunkReorderMap, bool keepBondNormalChunkOrder, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#1ad7e0c2e8685aeee34fc08c9d55e9f7">NvBlastBuildAssetDescChunkReorderMap</a> (uint32_t *chunkReorderMap, const <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#b86bb2afd5952d3c7c365e8162a0879b">NvBlastEnsureAssetExactSupportCoverage</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#0784e238a54e3cc64c4784ae8579a696">NvBlastReorderAssetDescChunks</a> (<a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *chunkDescs, uint32_t chunkCount, <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *bondDescs, uint32_t bondCount, uint32_t *chunkReorderMap, bool keepBondNormalChunkOrder, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#bc40350d116a07bcd0f7747acdf49c5a">NvBlastAssetCreateFamily</a> (void *mem, const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#b5c08bfc967cf0a532a1c1d80cb60558">NvBlastAssetGetActorSerializationSizeUpperBound</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#6ae69c8059e5d0dc7b771279109a792e">NvBlastAssetGetBondCount</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API const <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#112afc8391b220b8947cbd003bcae67a">NvBlastAssetGetBonds</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#51a2437f662febe3ad277602115aa26c">NvBlastAssetGetChunkCount</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API const <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#a8e719d16e9e4bc70afdcad1aaf2b070">NvBlastAssetGetChunks</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API const uint32_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#33aefb397327a574fff73de7060adac0">NvBlastAssetGetChunkToGraphNodeMap</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#8499eb2df3a5b53e71f2004a61b2a06f">NvBlastAssetGetFamilyMemorySize</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#1e866b60b08d7e765e2c56be8a06e438">NvBlastAssetGetFirstSubsupportChunkIndex</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#5797bde811db1c3562bbe5d3f36f6130">NvBlastAssetGetFormatVersion</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#0ccedb5841c20bebe9d39aae5aee56d7">NvBlastAssetGetID</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#8a75456d6b1fd43257a374b9317ad7d7">NvBlastAssetGetLeafChunkCount</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#88c03cb76de47b559441487b6f90ff67">NvBlastAssetGetSize</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#f0c1ab7b2b5f9daab051d2df10fcb03c">NvBlastAssetGetSupportChunkCount</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API const <br class="typebreak">
<a class="el" href="struct_nv_blast_support_graph.html">NvBlastSupportGraph</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#e11a0d11aefb7b7a1e0b57cb8b5b2e7b">NvBlastAssetGetSupportGraph</a> (const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#a6a3c5bb082495c5c48ce9ad0f6e80d9">NvBlastAssetSetID</a> (<a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> *id, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#dfed06b95f7c465681e3b3f87b60d1fb">NvBlastCreateAsset</a> (void *mem, const <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a> *desc, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#e687468738abd4123fc89b3e4109a995">NvBlastGetAssetMemorySize</a> (const <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a> *desc, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#3ea41c9a21d5572dbd8189660e18be95">NvBlastGetRequiredScratchForCreateAsset</a> (const <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a> *desc, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#b7ecca70eb3de1854f5fe0baecebf23f">NvBlastFamilyCreateFirstActor</a> (<a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, const <a class="el" href="struct_nv_blast_actor_desc.html">NvBlastActorDesc</a> *desc, void *scratch, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#f77263b30631016c45d852a463c33fcb">NvBlastFamilyDeserializeActor</a> (<a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, const void *buffer, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#f5afdfa868ba73c0dcde587633348e80">NvBlastFamilyGetActorCount</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#e24d3c471176690a4fcd58453e697811">NvBlastFamilyGetActors</a> (<a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> **actors, uint32_t actorsSize, const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#2fe3aec856668a6a8691d9505f43f60f">NvBlastFamilyGetAsset</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#3ccdaabdd9a51a9882a03bc8f72d9106">NvBlastFamilyGetAssetID</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#6d9f94752fd13a6a709b853899ade332">NvBlastFamilyGetChunkActor</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, uint32_t chunkIndex, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#64a3e89b0d917304c7ef999819ca2e74">NvBlastFamilyGetFormatVersion</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#ae6f08d1b81107160a6ba39a4496b435">NvBlastFamilyGetMaxActorCount</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#9253b7ab7f59f9ef5a604cc08bc23878">NvBlastFamilyGetRequiredScratchForCreateFirstActor</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#d9e290cc28e0d2d78624515e4a780091">NvBlastFamilyGetSize</a> (const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#bba1ed3118be03040e0cd99bf3180ddf">NvBlastFamilySetAsset</a> (<a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *family, const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *asset, <a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a> logFn)</td></tr>

<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#f06455f44aff50a4f80ee39f2eb0be2a">NvBlastTicksToSeconds</a> (int64_t ticks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NVBLAST_API void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="_nv_blast_8h.html#6a8135e333b2e84e418aa36fe0d4fcfa">NvBlastTimersReset</a> (<a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *timers)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="88efac48b308c27be2742ed601bcb32f"></a><!-- doxytag: member="NvBlast.h::NvBlastActorApplyFracture" ref="88efac48b308c27be2742ed601bcb32f" args="(NvBlastFractureBuffers *eventBuffers, NvBlastActor *actor, const NvBlastFractureBuffers *commands, NvBlastLog logFn, NvBlastTimers *timers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API void NvBlastActorApplyFracture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *&nbsp;</td>
          <td class="paramname"> <em>eventBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *&nbsp;</td>
          <td class="paramname"> <em>commands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies the direct fracture and breaks graph bonds/edges as necessary. Chunks damaged beyond their respective health fracture their children recursively, creating a <a class="el" href="struct_nv_blast_chunk_fracture_data.html">NvBlastChunkFractureData</a> for each.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>eventBuffers</em>&nbsp;</td><td>Target buffers to hold applied fracture events. May be NULL, in which case events are not reported. To avoid data loss, provide an entry for every lower-support chunk and every bond in the original actor. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> to apply fracture to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>commands</em>&nbsp;</td><td>The fracture commands to process. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timers</em>&nbsp;</td><td>If non-NULL this struct will be filled out with profiling information for the step, in profile build configurations.</td></tr>
  </table>
</dl>
Interpretation of <a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a>: commands: Counters denote the number of command entries to process. Chunk and Bond userdata are not used. Health values denote the amount of damage to apply, as a positive value.<p>
eventBuffers as input: Counters denote available entries for FractureData. Chunk and Bond userdata are not used. Health values are not used.<p>
eventBuffers as output: Counters denote valid entires in FractureData arrays. Chunks and Bond userdata reflect the respective userdata set during asset initialization. Health values denote how much health is remaining for the damaged element. Broken elements report a negative value corresponding to the superfluous health damage.<p>
commands and eventBuffers may point to the same memory. 
</div>
</div><p>
<a class="anchor" name="20bf7daebbc3804766c32fd6bd624a07"></a><!-- doxytag: member="NvBlast.h::NvBlastActorCanFracture" ref="20bf7daebbc3804766c32fd6bd624a07" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastActorCanFracture           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the actor can fracture further.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor potentially being fractured. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if any result can be expected from fracturing the actor. false if no further change to the actor is possible. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2293c45fd57fbe7cb448a849151907cf"></a><!-- doxytag: member="NvBlast.h::NvBlastActorDeactivate" ref="2293c45fd57fbe7cb448a849151907cf" args="(NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastActorDeactivate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deactivate an actor within its family. Conceptually this is "destroying" the actor, however memory will not be released until the family is released.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>Points to a user-supplied actor struct. May be NULL, in which case this function no-ops. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff successful (actor was active). </dd></dl>

</div>
</div><p>
<a class="anchor" name="befb2480ab1985d6fed58583050d57d2"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGenerateFracture" ref="befb2480ab1985d6fed58583050d57d2" args="(NvBlastFractureBuffers *commandBuffers, const NvBlastActor *actor, const NvBlastDamageProgram program, const void *programParams, NvBlastLog logFn, NvBlastTimers *timers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API void NvBlastActorGenerateFracture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a> *&nbsp;</td>
          <td class="paramname"> <em>commandBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_damage_program.html">NvBlastDamageProgram</a>&nbsp;</td>
          <td class="paramname"> <em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>programParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates fracture commands for the actor using a damage program and program parameters (material and damage descriptions).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>commandBuffers</em>&nbsp;</td><td>Target buffers to hold generated commands. To avoid data loss, provide an entry for every support chunk and every bond in the original actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> to create fracture commands for. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>program</em>&nbsp;</td><td>A <a class="el" href="struct_nv_blast_damage_program.html">NvBlastDamageProgram</a> containing damage shaders. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>programParams</em>&nbsp;</td><td>Parameters for the <a class="el" href="struct_nv_blast_damage_program.html">NvBlastDamageProgram</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timers</em>&nbsp;</td><td>If non-NULL this struct will be filled out with profiling information for the step, in profile build configurations.</td></tr>
  </table>
</dl>
Interpretation of <a class="el" href="struct_nv_blast_fracture_buffers.html">NvBlastFractureBuffers</a>: As input: Counters denote available entries for FractureData. Chunk and Bond userdata are not used. Health values are not used.<p>
As output: Counters denote valid entires in FractureData arrays. Chunks and Bond userdata reflect the respective userdata set during asset initialization, where implemented by the material function. Health values denote how much damage is to be applied. 
</div>
</div><p>
<a class="anchor" name="9d01e16dc02bed206adef7fcbf5935f0"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetBondHealths" ref="9d01e16dc02bed206adef7fcbf5935f0" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API const float* NvBlastActorGetBondHealths           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the bond health data for an actor.<p>
This function returns a pointer to the head of an array of bond healths (floats). This array is the same for any actor that has been created from repeated fracturing of the same original instance of an asset (in the same instance family).<p>
The indices obtained from <a class="el" href="struct_nv_blast_support_graph.html#e659d7f25dd6ae780f8cf14d7bf3925a">NvBlastSupportGraph::adjacentBondIndices</a> in the asset may be used to access this array.<p>
The size of the array returned is NvBlastAssetGetBondCount(asset, logFn), where 'asset' is the <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> that was used to create the actor.<p>
This array is valid as long as any actor in the instance family for the input actor exists.<p>
If the input actor is invalid, NULL will be returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the array of bond healths for the actor's instance family, or NULL if the actor is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="245ad453eda4f0102b5617f4edff9b66"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetFamily" ref="245ad453eda4f0102b5617f4edff9b66" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a>* NvBlastActorGetFamily           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to an actor's family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the family with which the actor is associated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec37b629f83ac2586e9edeb78f825e5c"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetGraphNodeCount" ref="ec37b629f83ac2586e9edeb78f825e5c" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetGraphNodeCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of graph nodes for this actor. May be used in conjunction with NvBlastActorGetGraphNodeIndices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of graph node indices for the actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c68e7844b84555aa74fa950d57469f1"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetGraphNodeIndices" ref="8c68e7844b84555aa74fa950d57469f1" args="(uint32_t *graphNodeIndices, uint32_t graphNodeIndicesSize, const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetGraphNodeIndices           </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>graphNodeIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>graphNodeIndicesSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a list of graph node indices for the actor into the given array.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>graphNodeIndices</em>&nbsp;</td><td>User-supplied array to be filled in with indices of graph nodes for this actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>graphNodeIndicesSize</em>&nbsp;</td><td>The size of the graphNodeIndices array. To receive all graph node indices, the size must be at least that given by NvBlastActorGetGraphNodeCount(actor). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of indices written to graphNodeIndices. This will not exceed graphNodeIndicesSize. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0b985e47f17306b7457a995fb1fc77cc"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetIndex" ref="0b985e47f17306b7457a995fb1fc77cc" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to an actor's internal index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>actor's internal index in family. </dd></dl>

</div>
</div><p>
<a class="anchor" name="95a908aa7b6e14e1ed881bf3cfe810d6"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetMaxActorCountForSplit" ref="95a908aa7b6e14e1ed881bf3cfe810d6" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetMaxActorCountForSplit           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the upper-bound number of actors which can be created by calling NvBlastActorSplit with that actor, this value can't exceed chunk count.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the upper-bound number of actors which can be created by calling NvBlastActorSplit with that actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66450acf095adeadc70d2a478c9ab2d1"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetRequiredScratchForSplit" ref="66450acf095adeadc70d2a478c9ab2d1" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API size_t NvBlastActorGetRequiredScratchForSplit           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of bytes of scratch memory that the user must supply to NvBlastActorSplit, based upon the actor that will be passed into that function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor that will be passed into NvBlastActorSplit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes of scratch memory required for a call to NvBlastActorSplit with that actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="32618a9eaafe25af758e4ffa33f36603"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetSerializationSize" ref="32618a9eaafe25af758e4ffa33f36603" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetSerializationSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The buffer size needed to serialize a single actor. This will give the exact size needed. For an upper bound on the buffer size needed for any actor instanced from an <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a>, use NvBlastAssetGetActorSerializationSizeUpperBound.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the required buffer size in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b103c80c01c2a4baeece9316bfcfc140"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetVisibleChunkCount" ref="b103c80c01c2a4baeece9316bfcfc140" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetVisibleChunkCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of visible chunks for this actor. May be used in conjunction with NvBlastActorGetVisibleChunkIndices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of visible chunk indices for the actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f04e1c60f327da97f1fbbc41e8c618f9"></a><!-- doxytag: member="NvBlast.h::NvBlastActorGetVisibleChunkIndices" ref="f04e1c60f327da97f1fbbc41e8c618f9" args="(uint32_t *visibleChunkIndices, uint32_t visibleChunkIndicesSize, const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorGetVisibleChunkIndices           </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>visibleChunkIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>visibleChunkIndicesSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a list of visible chunk indices for the actor into the given array.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>visibleChunkIndices</em>&nbsp;</td><td>User-supplied array to be filled in with indices of visible chunks for this actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>visibleChunkIndicesSize</em>&nbsp;</td><td>The size of the visibleChunkIndices array. To receive all visible chunk indices, the size must be at least that given by NvBlastActorGetVisibleChunkCount(actor). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of indices written to visibleChunkIndices. This will not exceed visibleChunkIndicesSize. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd7f66f53ab03e71eeeebaee7dec12b2"></a><!-- doxytag: member="NvBlast.h::NvBlastActorIsBoundToWorld" ref="dd7f66f53ab03e71eeeebaee7dec12b2" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastActorIsBoundToWorld           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff this actor contains the "world" support graph node, created when a bond contains the UINT32_MAX value for one of their chunkIndices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b330a0a7b654dfaa0c35f4c396a781e"></a><!-- doxytag: member="NvBlast.h::NvBlastActorIsSplitRequired" ref="8b330a0a7b654dfaa0c35f4c396a781e" args="(const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastActorIsSplitRequired           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the actor is damaged (was fractured) and split call is required.<p>
The actor could be damaged by calling NvBlastActorApplyFracture or NvBlastFamilyApplyFracture and NvBlastActorSplit is expected after. This function gives a hint that NvBlastActorSplit will have some work to be done and actor could potentially be split. If actor is not damaged calling NvBlastActorSplit will make no effect.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff split call is required for this actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="da0d2f72c83e2c2357ba8e93e5a3986e"></a><!-- doxytag: member="NvBlast.h::NvBlastActorSerialize" ref="da0d2f72c83e2c2357ba8e93e5a3986e" args="(void *buffer, uint32_t bufferSize, const NvBlastActor *actor, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorSerialize           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialize a single actor to a buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>User-supplied buffer, must be at least of size given by NvBlastActorGetSerializationSize(actor). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The size of the user-supplied buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written to the buffer, or 0 if there is an error (such as an under-sized buffer). </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccc0bb617daadd4554cb2224559a4dfc"></a><!-- doxytag: member="NvBlast.h::NvBlastActorSplit" ref="ccc0bb617daadd4554cb2224559a4dfc" args="(NvBlastActorSplitEvent *result, NvBlastActor *actor, uint32_t newActorsMaxCount, void *scratch, NvBlastLog logFn, NvBlastTimers *timers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastActorSplit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_actor_split_event.html">NvBlastActorSplitEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newActorsMaxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases the oldActor and creates its children newActors if necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>The list of deleted and created <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> objects. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>The actor to split. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newActorsMaxCount</em>&nbsp;</td><td>Number of available <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> slots. In the worst case, one <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> may be created for every chunk in the asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>Scratch Memory used during processing. NvBlastActorGetRequiredScratchForSplit provides the necessary size. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timers</em>&nbsp;</td><td>If non-NULL this struct will be filled out with profiling information for the step, in profile build configurations</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1..n: new actors were created <p>
0: oldActor is unchanged </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd731f119f9107a644167a14209c03f3"></a><!-- doxytag: member="NvBlast.h::NvBlastApplyAssetDescChunkReorderMap" ref="cd731f119f9107a644167a14209c03f3" args="(NvBlastChunkDesc *reorderedChunkDescs, const NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, NvBlastBondDesc *bondDescs, uint32_t bondCount, const uint32_t *chunkReorderMap, bool keepBondNormalChunkOrder, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API void NvBlastApplyAssetDescChunkReorderMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>reorderedChunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>bondDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bondCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkReorderMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keepBondNormalChunkOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply chunk reorder map.<p>
Function applies reorder map on <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> and <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> arrays. It reorders chunks, replaces their 'parentChunkIndex' field with new indices. Bonds are kept in the same order, but their 'chunkIndices' field is updated with proper indices.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="_nv_blast_8h.html#1ad7e0c2e8685aeee34fc08c9d55e9f7">NvBlastBuildAssetDescChunkReorderMap</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>reorderedChunkDescs</em>&nbsp;</td><td>User-supplied array of size chunkCount to fill with new reordered NvBlastChunkDesc's. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>Array of chunk descriptors of size chunkCount. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondDescs</em>&nbsp;</td><td>Array of bond descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondCount</em>&nbsp;</td><td>The number of bond descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkReorderMap</em>&nbsp;</td><td>Chunk reorder map to use, must be of size chunkCount. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keepBondNormalChunkOrder</em>&nbsp;</td><td>If true, bond normals will be flipped if their chunk index order was reveresed by the reorder map. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="94fd6269d5b3142d4035ae7e049b96b0"></a><!-- doxytag: member="NvBlast.h::NvBlastApplyAssetDescChunkReorderMapInPlace" ref="94fd6269d5b3142d4035ae7e049b96b0" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, NvBlastBondDesc *bondDescs, uint32_t bondCount, const uint32_t *chunkReorderMap, bool keepBondNormalChunkOrder, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API void NvBlastApplyAssetDescChunkReorderMapInPlace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>bondDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bondCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkReorderMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keepBondNormalChunkOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply chunk reorder map.<p>
Function applies reorder map on <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> and <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> arrays. It reorders chunks, replaces their 'parentChunkIndex' field with new indices. Bonds are kept in the same order, but their 'chunkIndices' field is updated with proper indices.<p>
This overload of function reorders chunks in place.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="_nv_blast_8h.html#1ad7e0c2e8685aeee34fc08c9d55e9f7">NvBlastBuildAssetDescChunkReorderMap</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>Array of chunk descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondDescs</em>&nbsp;</td><td>Array of bond descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondCount</em>&nbsp;</td><td>The number of bond descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkReorderMap</em>&nbsp;</td><td>Chunk reorder map to use, must be of size chunkCount. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keepBondNormalChunkOrder</em>&nbsp;</td><td>If true, bond normals will be flipped if their chunk index order was reveresed by the reorder map. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch storage, must point to chunkCount * sizeof(NvBlastChunkDesc) valid bytes of memory. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc40350d116a07bcd0f7747acdf49c5a"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetCreateFamily" ref="bc40350d116a07bcd0f7747acdf49c5a" args="(void *mem, const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a>* NvBlastAssetCreateFamily           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Family-building function.<p>
Constructs an <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> in-place at the address given by the user. The address must point to a block of memory of at least the size given by NvBlastAssetGetFamilyMemorySize(asset, logFn), and must be 16-byte aligned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mem</em>&nbsp;</td><td>Pointer to block of memory of at least the size given by NvBlastAssetGetFamilyMemorySize(asset, logFn). Must be 16-byte aligned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>Asset to instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the family. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5c08bfc967cf0a532a1c1d80cb60558"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetActorSerializationSizeUpperBound" ref="b5c08bfc967cf0a532a1c1d80cb60558" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetActorSerializationSizeUpperBound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A buffer size sufficient to serialize an actor instanced from a given asset. This function is faster than NvBlastActorGetSerializationSize, and can be used to create a reusable buffer for actor serialization.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the required buffer size in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ae69c8059e5d0dc7b771279109a792e"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetBondCount" ref="6ae69c8059e5d0dc7b771279109a792e" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetBondCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of bonds in the given asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bonds in the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="112afc8391b220b8947cbd003bcae67a"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetBonds" ref="112afc8391b220b8947cbd003bcae67a" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API const <a class="el" href="struct_nv_blast_bond.html">NvBlastBond</a>* NvBlastAssetGetBonds           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access an array of bonds of the given asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User - supplied message function(see NvBlastLog definition).May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to an array of bonds of the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="51a2437f662febe3ad277602115aa26c"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetChunkCount" ref="51a2437f662febe3ad277602115aa26c" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetChunkCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of chunks in the given asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of chunks in the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8e719d16e9e4bc70afdcad1aaf2b070"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetChunks" ref="a8e719d16e9e4bc70afdcad1aaf2b070" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API const <a class="el" href="struct_nv_blast_chunk.html">NvBlastChunk</a>* NvBlastAssetGetChunks           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access an array of chunks of the given asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User - supplied message function(see NvBlastLog definition).May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to an array of chunks of the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="33aefb397327a574fff73de7060adac0"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetChunkToGraphNodeMap" ref="33aefb397327a574fff73de7060adac0" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API const uint32_t* NvBlastAssetGetChunkToGraphNodeMap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access a map from chunk index to graph node index. Returned map is valid in the domain [0, NvBlastAssetGetChunkCount(asset, logFn)). Non-support chunks are mapped to the invalid index 0xFFFFFFFF.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an array of uint32_t values defining the map, of size NvBlastAssetGetChunkCount(asset, logFn). </dd></dl>

</div>
</div><p>
<a class="anchor" name="8499eb2df3a5b53e71f2004a61b2a06f"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetFamilyMemorySize" ref="8499eb2df3a5b53e71f2004a61b2a06f" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API size_t NvBlastAssetGetFamilyMemorySize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the memory requirements for a family based upon an asset. Use this function when building a family with NvBlastAssetCreateFamily.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>Asset used to build the family (see <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the memory size (in bytes) required for the family, or zero if asset is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e866b60b08d7e765e2c56be8a06e438"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetFirstSubsupportChunkIndex" ref="1e866b60b08d7e765e2c56be8a06e438" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetFirstSubsupportChunkIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first subsupport chunk index in the given asset. Chunks are sorted such that subsupport chunks come last. This is the first subsupport chunk index. Equals to total chunk count if there are no subsupport chunks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the first subsupport chunk index in the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5797bde811db1c3562bbe5d3f36f6130"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetFormatVersion" ref="5797bde811db1c3562bbe5d3f36f6130" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetFormatVersion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the data format version for the given asset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. Cannot be NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the data format version (NvBlastAssetDataFormat). </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ccedb5841c20bebe9d39aae5aee56d7"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetID" ref="0ccedb5841c20bebe9d39aae5aee56d7" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> NvBlastAssetGetID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the asset ID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The given asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the ID of the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a75456d6b1fd43257a374b9317ad7d7"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetLeafChunkCount" ref="8a75456d6b1fd43257a374b9317ad7d7" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetLeafChunkCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of leaf chunks in the given asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of leaf chunks in the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88c03cb76de47b559441487b6f90ff67"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetSize" ref="88c03cb76de47b559441487b6f90ff67" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the memory size (in bytes) of the given data asset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. Cannot be NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the memory size of the asset (in bytes). </dd></dl>

</div>
</div><p>
<a class="anchor" name="f0c1ab7b2b5f9daab051d2df10fcb03c"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetSupportChunkCount" ref="f0c1ab7b2b5f9daab051d2df10fcb03c" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastAssetGetSupportChunkCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of support chunks in the given asset. This will equal the number of graph nodes in <a class="el" href="struct_nv_blast_support_graph.html#ac2f6bdd02cc6ed2b30af8f3099d072f">NvBlastSupportGraph::nodeCount</a> returned by NvBlastAssetGetSupportGraph only if no extra "world" node was created due to bonds defined between support chunks and the world. If such bonds were created, then there is an extra graph node representing the world, and this function will return <a class="el" href="struct_nv_blast_support_graph.html#ac2f6bdd02cc6ed2b30af8f3099d072f">NvBlastSupportGraph::nodeCount</a> - 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of chunks in the asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e11a0d11aefb7b7a1e0b57cb8b5b2e7b"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetGetSupportGraph" ref="e11a0d11aefb7b7a1e0b57cb8b5b2e7b" args="(const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API const <a class="el" href="struct_nv_blast_support_graph.html">NvBlastSupportGraph</a> NvBlastAssetGetSupportGraph           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the support graph for the given asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a struct of support graph for the given asset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a6a3c5bb082495c5c48ce9ad0f6e80d9"></a><!-- doxytag: member="NvBlast.h::NvBlastAssetSetID" ref="a6a3c5bb082495c5c48ce9ad0f6e80d9" args="(NvBlastAsset *asset, const NvBlastID *id, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastAssetSetID           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> *&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an asset's ID<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>The given asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>A pointer to the id to copy into the asset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the id is successfully set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ad7e0c2e8685aeee34fc08c9d55e9f7"></a><!-- doxytag: member="NvBlast.h::NvBlastBuildAssetDescChunkReorderMap" ref="1ad7e0c2e8685aeee34fc08c9d55e9f7" args="(uint32_t *chunkReorderMap, const NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastBuildAssetDescChunkReorderMap           </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkReorderMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build chunk reorder map.<p>
NvBlastCreateAsset function requires <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> array to be in correct oder:<p>
1. Root chunks (chunks with invalid parent index) must be first in the asset's chunk list. 2. Chunks in the asset must be arranged such that sibling chunks (chunks with the same parent) are contiguous. 3. Chunks must be arranged such that upper-support chunks (support chunks and their parent chunks) go first in chunk list.<p>
This function builds chunk reorder map which can be used to order chunk descs. Reordering chunk's descriptors according to generated map places them in correct order for NvBlastCreateAsset to succeed.<p>
Iff chunks are already ordered correctly, function returns 'true' and identity chunk reorder map. Otherwise 'false' is returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>chunkReorderMap</em>&nbsp;</td><td>User-supplied map of size chunkCount to fill. For every chunk index this array will contain new chunk position (index). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>Array of chunk descriptors of size chunkCount. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch storage, must point to 2 * chunkCount * sizeof(uint32_t) valid bytes of memory. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the chunks did not require reordering (chunkReorderMap is the identity map). </dd></dl>

</div>
</div><p>
<a class="anchor" name="dfed06b95f7c465681e3b3f87b60d1fb"></a><!-- doxytag: member="NvBlast.h::NvBlastCreateAsset" ref="dfed06b95f7c465681e3b3f87b60d1fb" args="(void *mem, const NvBlastAssetDesc *desc, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a>* NvBlastCreateAsset           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asset-building function.<p>
Constructs an <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> in-place at the address given by the user. The address must point to a block of memory of at least the size given by NvBlastGetAssetMemorySize(desc, logFn), and must be 16-byte aligned.<p>
Support chunks (marked in the <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> struct) must provide full coverage over the asset. This means that from any leaf chunk to the root node, exactly one chunk must be support. If this condition is not met the function fails to create an asset.<p>
Any bonds described by <a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> descriptors that reference non-support chunks will be removed. Duplicate bonds will be removed as well (bonds that are between the same chunk pairs).<p>
Chunks in the asset should be arranged such that sibling chunks (chunks with the same parent) are contiguous. Chunks are also should be arranged such that leaf chunks (chunks with no children) are at the end of the chunk list. If chunks aren't arranged properly the function fails to create an asset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mem</em>&nbsp;</td><td>Pointer to block of memory of at least the size given by NvBlastGetAssetMemorySize(desc, logFn). Must be 16-byte aligned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Asset descriptor (see <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch memory of size NvBlastGetRequiredScratchForCreateAsset(desc) bytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to new <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> (will be the same address as mem), or NULL if unsuccessful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b86bb2afd5952d3c7c365e8162a0879b"></a><!-- doxytag: member="NvBlast.h::NvBlastEnsureAssetExactSupportCoverage" ref="b86bb2afd5952d3c7c365e8162a0879b" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastEnsureAssetExactSupportCoverage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to ensure (check and update) support coverage of chunks.<p>
Support chunks (marked in the <a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> struct) must provide full coverage over the asset. This means that from any leaf chunk to the root node, exactly one chunk must be support. If this condition is not met, the actual support chunks will be adjusted accordingly.<p>
Chunk order depends on support coverage, so this function should be called before chunk reordering.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>Array of chunk descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch storage, must point to chunkCount valid bytes of memory. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff coverage was already exact. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7ecca70eb3de1854f5fe0baecebf23f"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyCreateFirstActor" ref="b7ecca70eb3de1854f5fe0baecebf23f" args="(NvBlastFamily *family, const NvBlastActorDesc *desc, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a>* NvBlastFamilyCreateFirstActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_actor_desc.html">NvBlastActorDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instance the family's asset into a new, unfractured actor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>Family in which to create a new actor. The family must have no other actors in it. (See NvBlastAssetCreateFamily.) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Actor descriptor (see <a class="el" href="struct_nv_blast_actor_desc.html">NvBlastActorDesc</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch memory of size NvBlastFamilyGetRequiredScratchForCreateFirstActor(asset) bytes, where 'asset' is the <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> from which the family was created. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to new <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> if successful (the actor was successfully inserted into the family), or NULL if unsuccessful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f77263b30631016c45d852a463c33fcb"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyDeserializeActor" ref="f77263b30631016c45d852a463c33fcb" args="(NvBlastFamily *family, const void *buffer, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a>* NvBlastFamilyDeserializeActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deserialize a single Actor from a buffer into the given family. The actor will be inserted if it is compatible with the current family state. That is, it must not share any chunks or internal IDs with the actors already present in the family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>Family in which to deserialize the actor. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>User-supplied buffer containing the actor to deserialize. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the deserialized actor if successful, NULL otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5afdfa868ba73c0dcde587633348e80"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetActorCount" ref="f5afdfa868ba73c0dcde587633348e80" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastFamilyGetActorCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the number of active actors associated with the given family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of active actors in the family. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e24d3c471176690a4fcd58453e697811"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetActors" ref="e24d3c471176690a4fcd58453e697811" args="(NvBlastActor **actors, uint32_t actorsSize, const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastFamilyGetActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a> **&nbsp;</td>
          <td class="paramname"> <em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>actorsSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the active actors associated with the given family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>actors</em>&nbsp;</td><td>User-supplied array to be filled with the returned actor pointers. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>actorsSize</em>&nbsp;</td><td>The size of the actors array. To receive all actor pointers, the size must be at least that given by NvBlastFamilyGetActorCount(family). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of actor pointers written to actors. This will not exceed actorsSize. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fe3aec856668a6a8691d9505f43f60f"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetAsset" ref="2fe3aec856668a6a8691d9505f43f60f" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a>* NvBlastFamilyGetAsset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the asset of the given family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the asset associated with the family. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ccdaabdd9a51a9882a03bc8f72d9106"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetAssetID" ref="3ccdaabdd9a51a9882a03bc8f72d9106" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_i_d.html">NvBlastID</a> NvBlastFamilyGetAssetID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the asset ID of the given family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the ID of the asset associated with the family. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d9f94752fd13a6a709b853899ade332"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetChunkActor" ref="6d9f94752fd13a6a709b853899ade332" args="(const NvBlastFamily *family, uint32_t chunkIndex, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API <a class="el" href="struct_nv_blast_actor.html">NvBlastActor</a>* NvBlastFamilyGetChunkActor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the actor associated with the given chunk.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkIndex</em>&nbsp;</td><td>The index of chunk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to actor associated with given chunk. NULL if there is no such actor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64a3e89b0d917304c7ef999819ca2e74"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetFormatVersion" ref="64a3e89b0d917304c7ef999819ca2e74" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastFamilyGetFormatVersion           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the data format version for the given family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the family format version. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae6f08d1b81107160a6ba39a4496b435"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetMaxActorCount" ref="ae6f08d1b81107160a6ba39a4496b435" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastFamilyGetMaxActorCount           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the max active actor count family could have.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the max number of active actors family could have. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9253b7ab7f59f9ef5a604cc08bc23878"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetRequiredScratchForCreateFirstActor" ref="9253b7ab7f59f9ef5a604cc08bc23878" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API size_t NvBlastFamilyGetRequiredScratchForCreateFirstActor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of bytes of scratch memory that the user must supply to NvBlastFamilyCreateFirstActor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family from which the first actor will be instanced. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes of scratch memory required for a call to NvBlastFamilyCreateFirstActor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d9e290cc28e0d2d78624515e4a780091"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilyGetSize" ref="d9e290cc28e0d2d78624515e4a780091" args="(const NvBlastFamily *family, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API uint32_t NvBlastFamilyGetSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the size (in bytes) of the given family.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the family (in bytes). </dd></dl>

</div>
</div><p>
<a class="anchor" name="bba1ed3118be03040e0cd99bf3180ddf"></a><!-- doxytag: member="NvBlast.h::NvBlastFamilySetAsset" ref="bba1ed3118be03040e0cd99bf3180ddf" args="(NvBlastFamily *family, const NvBlastAsset *asset, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API void NvBlastFamilySetAsset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_family.html">NvBlastFamily</a> *&nbsp;</td>
          <td class="paramname"> <em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset.html">NvBlastAsset</a> *&nbsp;</td>
          <td class="paramname"> <em>asset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set asset to the family. It should be the same asset as the one family was created from (same ID).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>family</em>&nbsp;</td><td>The family. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>asset</em>&nbsp;</td><td>Asset to instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e687468738abd4123fc89b3e4109a995"></a><!-- doxytag: member="NvBlast.h::NvBlastGetAssetMemorySize" ref="e687468738abd4123fc89b3e4109a995" args="(const NvBlastAssetDesc *desc, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API size_t NvBlastGetAssetMemorySize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the memory requirements for an asset based upon its descriptor. Use this function when building an asset with NvBlastCreateAsset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>Asset descriptor (see <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the memory size (in bytes) required for the asset, or zero if desc is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ea41c9a21d5572dbd8189660e18be95"></a><!-- doxytag: member="NvBlast.h::NvBlastGetRequiredScratchForCreateAsset" ref="3ea41c9a21d5572dbd8189660e18be95" args="(const NvBlastAssetDesc *desc, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API size_t NvBlastGetRequiredScratchForCreateAsset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_nv_blast_asset_desc.html">NvBlastAssetDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of bytes of scratch memory that the user must supply to NvBlastCreateAsset, based upon the descriptor that will be passed into that function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The asset descriptor that will be passed into NvBlastCreateAsset. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes of scratch memory required for a call to NvBlastCreateAsset with that descriptor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0784e238a54e3cc64c4784ae8579a696"></a><!-- doxytag: member="NvBlast.h::NvBlastReorderAssetDescChunks" ref="0784e238a54e3cc64c4784ae8579a696" args="(NvBlastChunkDesc *chunkDescs, uint32_t chunkCount, NvBlastBondDesc *bondDescs, uint32_t bondCount, uint32_t *chunkReorderMap, bool keepBondNormalChunkOrder, void *scratch, NvBlastLog logFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API bool NvBlastReorderAssetDescChunks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_chunk_desc.html">NvBlastChunkDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>chunkDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>chunkCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_bond_desc.html">NvBlastBondDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>bondDescs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bondCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>chunkReorderMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>keepBondNormalChunkOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_nv_blast_types_8h.html#fa1be237d696dc68e343189c19cc76e0">NvBlastLog</a>&nbsp;</td>
          <td class="paramname"> <em>logFn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build and apply chunk reorder map.<p>
Function basically calls NvBlastBuildAssetDescChunkReorderMap and NvBlastApplyAssetDescChunkReorderMap. Used for Convenience.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkDescs</em>&nbsp;</td><td>Array of chunk descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkCount</em>&nbsp;</td><td>The number of chunk descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondDescs</em>&nbsp;</td><td>Array of bond descriptors of size chunkCount. It will be updated accordingly. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bondCount</em>&nbsp;</td><td>The number of bond descriptors. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>chunkReorderMap</em>&nbsp;</td><td>Chunk reorder map to fill, must be of size chunkCount. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>keepBondNormalChunkOrder</em>&nbsp;</td><td>If true, bond normals will be flipped if their chunk index order was reveresed by the reorder map. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>User-supplied scratch storage, must point to chunkCount * sizeof(NvBlastChunkDesc) valid bytes of memory. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>logFn</em>&nbsp;</td><td>User-supplied message function (see NvBlastLog definition). May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true iff the chunks did not require reordering (chunkReorderMap is the identity map). </dd></dl>

</div>
</div><p>
<a class="anchor" name="f06455f44aff50a4f80ee39f2eb0be2a"></a><!-- doxytag: member="NvBlast.h::NvBlastTicksToSeconds" ref="f06455f44aff50a4f80ee39f2eb0be2a" args="(int64_t ticks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API double NvBlastTicksToSeconds           </td>
          <td>(</td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"> <em>ticks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert a tick value from <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> to seconds.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ticks</em>&nbsp;</td><td>The tick value.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the seconds correposnding to the input tick value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a8135e333b2e84e418aa36fe0d4fcfa"></a><!-- doxytag: member="NvBlast.h::NvBlastTimersReset" ref="6a8135e333b2e84e418aa36fe0d4fcfa" args="(NvBlastTimers *timers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NVBLAST_API void NvBlastTimersReset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> *&nbsp;</td>
          <td class="paramname"> <em>timers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets all values in the given <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> struct to zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timers</em>&nbsp;</td><td>The <a class="el" href="struct_nv_blast_timers.html">NvBlastTimers</a> to set to zero. </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
