<html>
	<head>
		<title>NVIDIA(R) Blast(R) SDK 1.1 Source Reference: sdk/extensions/authoring/source/VHACD/inc/vhacdVHACD.h Source File</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<hr class="first">
			<img alt="" src="blast_logo.png">
			<br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<!-- <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; //-->
				<a class="qindex" href="annotated.html">Class List</a> &nbsp; 
				<a class="qindex" href="functions.html">Class Members</a> &nbsp;  
			</center>
			<hr class="second">
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>User's&nbsp;Guide</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>sdk/extensions/authoring/source/VHACD/inc/vhacdVHACD.h</h1><a href="vhacd_v_h_a_c_d_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright (c) 2011 Khaled Mamou (kmamou at gmail dot com)</span>
<a name="l00002"></a>00002 <span class="comment">All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment"></span>
<a name="l00005"></a>00005 <span class="comment">Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">3. The names of the contributors may not be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00014"></a>00014 <span class="comment">*/</span>
<a name="l00015"></a>00015 <span class="preprocessor">#pragma once</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#ifndef VHACD_VHACD_H</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#define VHACD_VHACD_H</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 <span class="preprocessor">#ifdef OPENCL_FOUND</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#ifdef __MACH__</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#include &lt;OpenCL/cl.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#else</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#include &lt;CL/cl.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#endif</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#endif //OPENCL_FOUND</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#include "<a class="code" href="vhacd_mutex_8h.html">vhacdMutex.h</a>"</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include "<a class="code" href="vhacd_volume_8h.html">vhacdVolume.h</a>"</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include "<a class="code" href="vhacd_raycast_mesh_8h.html">vhacdRaycastMesh.h</a>"</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="vhacd_v_h_a_c_d_8h.html#7d57e139757b24d6554cca6cf9237335">00032</a> <span class="keyword">typedef</span> std::vector&lt; VHACD::IVHACD::Constraint &gt; <a class="code" href="vhacd_v_h_a_c_d_8h.html#7d57e139757b24d6554cca6cf9237335">ConstraintVector</a>;
<a name="l00033"></a>00033 
<a name="l00034"></a><a class="code" href="vhacd_v_h_a_c_d_8h.html#f62c578b7ec797d3efca9da2cafd82a9">00034</a> <span class="preprocessor">#define USE_THREAD 1</span>
<a name="l00035"></a><a class="code" href="vhacd_v_h_a_c_d_8h.html#98105bf63d2188374c64df6afc5d3fc4">00035</a> <span class="preprocessor"></span><span class="preprocessor">#define OCL_MIN_NUM_PRIMITIVES 4096</span>
<a name="l00036"></a><a class="code" href="vhacd_v_h_a_c_d_8h.html#0c437a2f10c2744274175758659c6b3f">00036</a> <span class="preprocessor"></span><span class="preprocessor">#define CH_APP_MIN_NUM_PRIMITIVES 64000</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="keyword">namespace </span>VHACD {
<a name="l00038"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html">00038</a> <span class="keyword">class </span><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html">VHACD</a> : <span class="keyword">public</span> <a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d.html">IVHACD</a> {
<a name="l00039"></a>00039 <span class="keyword">public</span>:
<a name="l00041"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#bbb2b701be0a9fe1fe29c7254d1a142f">00041</a>     <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#bbb2b701be0a9fe1fe29c7254d1a142f" title="Constructor.">VHACD</a>()
<a name="l00042"></a>00042     {
<a name="l00043"></a>00043 <span class="preprocessor">#if USE_THREAD == 1 &amp;&amp; _OPENMP</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span>        m_ompNumProcessors = 2 * omp_get_num_procs();
<a name="l00045"></a>00045         omp_set_num_threads(m_ompNumProcessors);
<a name="l00046"></a>00046 <span class="preprocessor">#else //USE_THREAD == 1 &amp;&amp; _OPENMP</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span>        m_ompNumProcessors = 1;
<a name="l00048"></a>00048 <span class="preprocessor">#endif //USE_THREAD == 1 &amp;&amp; _OPENMP</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#ifdef CL_VERSION_1_1</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>        m_oclWorkGroupSize = 0;
<a name="l00051"></a>00051         m_oclDevice = 0;
<a name="l00052"></a>00052         m_oclQueue = 0;
<a name="l00053"></a>00053         m_oclKernelComputePartialVolumes = 0;
<a name="l00054"></a>00054         m_oclKernelComputeSum = 0;
<a name="l00055"></a>00055 <span class="preprocessor">#endif //CL_VERSION_1_1</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>        Init();
<a name="l00057"></a>00057     }
<a name="l00059"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#1e6710dffbd0f288feb4d81853ce4bd2">00059</a>     <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#1e6710dffbd0f288feb4d81853ce4bd2" title="Destructor.">~VHACD</a>(<span class="keywordtype">void</span>) 
<a name="l00060"></a>00060     {
<a name="l00061"></a>00061     }
<a name="l00062"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#9d83d6e163e1dacc271e67a55d376f78">00062</a>     uint32_t <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#9d83d6e163e1dacc271e67a55d376f78">GetNConvexHulls</a>()<span class="keyword"> const</span>
<a name="l00063"></a>00063 <span class="keyword">    </span>{
<a name="l00064"></a>00064         <span class="keywordflow">return</span> (uint32_t)m_convexHulls.<a class="code" href="class_v_h_a_c_d_1_1_s_array.html#d72193179c4d43b70d14fb2ea6a11f0a">Size</a>();
<a name="l00065"></a>00065     }
<a name="l00066"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#9e1063dde19bc3525e4965475a0a9ea0">00066</a>     <span class="keywordtype">void</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#9e1063dde19bc3525e4965475a0a9ea0">Cancel</a>()
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068         SetCancel(<span class="keyword">true</span>);
<a name="l00069"></a>00069     }
<a name="l00070"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#0a339ca3e621766e6eca0d180c8a9365">00070</a>     <span class="keywordtype">void</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#0a339ca3e621766e6eca0d180c8a9365">GetConvexHull</a>(<span class="keyword">const</span> uint32_t index, <a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html">ConvexHull</a>&amp; ch)<span class="keyword"> const</span>
<a name="l00071"></a>00071 <span class="keyword">    </span>{
<a name="l00072"></a>00072         <a class="code" href="class_v_h_a_c_d_1_1_mesh.html" title="Triangular mesh data structure.">Mesh</a>* mesh = m_convexHulls[index];
<a name="l00073"></a>00073         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#eb9ec835d1d9963845f19f4716016588">m_nPoints</a> = (uint32_t)mesh-&gt;<a class="code" href="class_v_h_a_c_d_1_1_mesh.html#bfd1ac1ba33eed1aeee61f1ed7706028">GetNPoints</a>();
<a name="l00074"></a>00074         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#586b4a3ce6f875324896e57e00336df4">m_nTriangles</a> = (uint32_t)mesh-&gt;<a class="code" href="class_v_h_a_c_d_1_1_mesh.html#da340b478800d86f0e9c0f7ad5f5ac39">GetNTriangles</a>();
<a name="l00075"></a>00075         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#42c7c8ef3166b2e12937931598779697">m_points</a> = mesh-&gt;<a class="code" href="class_v_h_a_c_d_1_1_mesh.html#7d6cb754fe7e0bcb37c4ac9e30349588">GetPoints</a>();
<a name="l00076"></a>00076         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#41d660741580616f46b4be834d9881c7">m_triangles</a> = (uint32_t *)mesh-&gt;<a class="code" href="class_v_h_a_c_d_1_1_mesh.html#160e8b48839291641fec040a8aff8398">GetTriangles</a>();
<a name="l00077"></a>00077         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#68f0ed83874db02164ca2faf63f0c169">m_volume</a> = mesh-&gt;<a class="code" href="class_v_h_a_c_d_1_1_mesh.html#640488a83fefc3321b995dbdeb54c889">ComputeVolume</a>();
<a name="l00078"></a>00078         <a class="code" href="class_v_h_a_c_d_1_1_vec3.html">Vec3&lt;double&gt;</a> &amp;center = mesh-&gt;<a class="code" href="class_v_h_a_c_d_1_1_mesh.html#d35b8d2444ff5d1b8fc790e1f73f0e6c">ComputeCenter</a>();
<a name="l00079"></a>00079         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#849b4845ce4288b5d9a1e3513fd2e95a">m_center</a>[0] = center.<a class="code" href="class_v_h_a_c_d_1_1_vec3.html#46b34cc6f3a95b3cf29aeccc3a700ccb">X</a>();
<a name="l00080"></a>00080         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#849b4845ce4288b5d9a1e3513fd2e95a">m_center</a>[1] = center.<a class="code" href="class_v_h_a_c_d_1_1_vec3.html#ce84816bc7d1ced8aa848b72d4c0dfc7">Y</a>();
<a name="l00081"></a>00081         ch.<a class="code" href="class_v_h_a_c_d_1_1_i_v_h_a_c_d_1_1_convex_hull.html#849b4845ce4288b5d9a1e3513fd2e95a">m_center</a>[2] = center.<a class="code" href="class_v_h_a_c_d_1_1_vec3.html#e654437eebd4d4dd0002e492bdfddbe2">Z</a>();
<a name="l00082"></a>00082     }
<a name="l00083"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#6e5ad0c3d528c3df0edb367ca8e8d9dc">00083</a>     <span class="keywordtype">void</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#6e5ad0c3d528c3df0edb367ca8e8d9dc">Clean</a>(<span class="keywordtype">void</span>)
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085         <span class="keywordflow">if</span> (mRaycastMesh)
<a name="l00086"></a>00086         {
<a name="l00087"></a>00087             mRaycastMesh-&gt;release();
<a name="l00088"></a>00088             mRaycastMesh = <span class="keyword">nullptr</span>;
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090         <span class="keyword">delete</span> m_volume;
<a name="l00091"></a>00091         <span class="keyword">delete</span> m_pset;
<a name="l00092"></a>00092         <span class="keywordtype">size_t</span> nCH = m_convexHulls.<a class="code" href="class_v_h_a_c_d_1_1_s_array.html#d72193179c4d43b70d14fb2ea6a11f0a">Size</a>();
<a name="l00093"></a>00093         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; nCH; ++p) {
<a name="l00094"></a>00094             <span class="keyword">delete</span> m_convexHulls[p];
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096         m_convexHulls.<a class="code" href="class_v_h_a_c_d_1_1_s_array.html#beb520e448c4b4f6b53b001a5fe6f609">Clear</a>();
<a name="l00097"></a>00097         Init();
<a name="l00098"></a>00098     }
<a name="l00099"></a><a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#148a88808c26e2a6109ef8f6e1fcab7c">00099</a>     <span class="keywordtype">void</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#148a88808c26e2a6109ef8f6e1fcab7c">Release</a>(<span class="keywordtype">void</span>)
<a name="l00100"></a>00100     {
<a name="l00101"></a>00101         <span class="keyword">delete</span> <span class="keyword">this</span>;
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103     <span class="keywordtype">bool</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#1553450568fbefebc4100710d336bd9b">Compute</a>(<span class="keyword">const</span> <span class="keywordtype">float</span>* <span class="keyword">const</span> points,
<a name="l00104"></a>00104         <span class="keyword">const</span> uint32_t nPoints,
<a name="l00105"></a>00105         <span class="keyword">const</span> uint32_t* <span class="keyword">const</span> triangles,
<a name="l00106"></a>00106         <span class="keyword">const</span> uint32_t nTriangles,
<a name="l00107"></a>00107         <span class="keyword">const</span> Parameters&amp; params);
<a name="l00108"></a>00108     <span class="keywordtype">bool</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#1553450568fbefebc4100710d336bd9b">Compute</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> points,
<a name="l00109"></a>00109         <span class="keyword">const</span> uint32_t nPoints,
<a name="l00110"></a>00110         <span class="keyword">const</span> uint32_t* <span class="keyword">const</span> triangles,
<a name="l00111"></a>00111         <span class="keyword">const</span> uint32_t nTriangles,
<a name="l00112"></a>00112         <span class="keyword">const</span> Parameters&amp; params);
<a name="l00113"></a>00113     <span class="keywordtype">bool</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#0ecdc45cc18df1858fac9f5ad48663ae">OCLInit</a>(<span class="keywordtype">void</span>* <span class="keyword">const</span> oclDevice,
<a name="l00114"></a>00114         IUserLogger* <span class="keyword">const</span> logger = 0);
<a name="l00115"></a>00115     <span class="keywordtype">bool</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#419a895005c5e8ab7d8491aff1579b7d">OCLRelease</a>(IUserLogger* <span class="keyword">const</span> logger = 0);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#ce03bd6e3fdd5b4681991728c7d4577a">ComputeCenterOfMass</a>(<span class="keywordtype">double</span> centerOfMass[3]) <span class="keyword">const</span>;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     <span class="comment">// Will analyze the HACD results and compute the constraints solutions.</span>
<a name="l00120"></a>00120     <span class="comment">// It will analyze the point at which any two convex hulls touch each other and </span>
<a name="l00121"></a>00121     <span class="comment">// return the total number of constraint pairs found</span>
<a name="l00122"></a>00122     <span class="keyword">virtual</span> uint32_t <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#8007aad223bbd6002ef47a202f6b714f">ComputeConstraints</a>(<span class="keywordtype">void</span>);
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <span class="comment">// Returns a pointer to the constraint index; null if the index is not valid or</span>
<a name="l00125"></a>00125     <span class="comment">// the user did not previously call 'ComputeConstraints' </span>
<a name="l00126"></a>00126     <span class="keyword">virtual</span> <span class="keyword">const</span> Constraint *<a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#52714e73da2399664d05d631ab838767">GetConstraint</a>(uint32_t index) <span class="keyword">const</span>;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keyword">private</span>:
<a name="l00129"></a>00129     <span class="keywordtype">void</span> SetCancel(<span class="keywordtype">bool</span> cancel)
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131         m_cancelMutex.<a class="code" href="class_v_h_a_c_d_1_1_mutex.html#9efefb1299fc74f136abe8a545bd5b3d">Lock</a>();
<a name="l00132"></a>00132         m_cancel = cancel;
<a name="l00133"></a>00133         m_cancelMutex.<a class="code" href="class_v_h_a_c_d_1_1_mutex.html#8fb030351ef3a6d191fef6a55f7d1d68">Unlock</a>();
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     <span class="keywordtype">bool</span> GetCancel()
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         m_cancelMutex.Lock();
<a name="l00139"></a>00139         <span class="keywordtype">bool</span> cancel = m_cancel;
<a name="l00140"></a>00140         m_cancelMutex.Unlock();
<a name="l00141"></a>00141         <span class="keywordflow">return</span> cancel;
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143     <span class="keywordtype">void</span> Update(<span class="keyword">const</span> <span class="keywordtype">double</span> stageProgress,
<a name="l00144"></a>00144         <span class="keyword">const</span> <span class="keywordtype">double</span> operationProgress,
<a name="l00145"></a>00145         <span class="keyword">const</span> Parameters&amp; params)
<a name="l00146"></a>00146     {
<a name="l00147"></a>00147         m_stageProgress = stageProgress;
<a name="l00148"></a>00148         m_operationProgress = operationProgress;
<a name="l00149"></a>00149         <span class="keywordflow">if</span> (params.m_callback) {
<a name="l00150"></a>00150             params.m_callback-&gt;Update(m_overallProgress,
<a name="l00151"></a>00151                 m_stageProgress,
<a name="l00152"></a>00152                 m_operationProgress,
<a name="l00153"></a>00153                 m_stage.c_str(),
<a name="l00154"></a>00154                 m_operation.c_str());
<a name="l00155"></a>00155         }
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157     <span class="keywordtype">void</span> Init()
<a name="l00158"></a>00158     {
<a name="l00159"></a>00159         <span class="keywordflow">if</span> (mRaycastMesh)
<a name="l00160"></a>00160         {
<a name="l00161"></a>00161             mRaycastMesh-&gt;release();
<a name="l00162"></a>00162             mRaycastMesh = <span class="keyword">nullptr</span>;
<a name="l00163"></a>00163         }
<a name="l00164"></a>00164         memset(m_rot, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * 9);
<a name="l00165"></a>00165         m_dim = 64;
<a name="l00166"></a>00166         m_volume = 0;
<a name="l00167"></a>00167         m_volumeCH0 = 0.0;
<a name="l00168"></a>00168         m_pset = 0;
<a name="l00169"></a>00169         m_overallProgress = 0.0;
<a name="l00170"></a>00170         m_stageProgress = 0.0;
<a name="l00171"></a>00171         m_operationProgress = 0.0;
<a name="l00172"></a>00172         m_stage = <span class="stringliteral">""</span>;
<a name="l00173"></a>00173         m_operation = <span class="stringliteral">""</span>;
<a name="l00174"></a>00174         m_barycenter[0] = m_barycenter[1] = m_barycenter[2] = 0.0;
<a name="l00175"></a>00175         m_rot[0][0] = m_rot[1][1] = m_rot[2][2] = 1.0;
<a name="l00176"></a>00176         SetCancel(<span class="keyword">false</span>);
<a name="l00177"></a>00177     }
<a name="l00178"></a>00178     <span class="keywordtype">void</span> ComputePrimitiveSet(<span class="keyword">const</span> Parameters&amp; params);
<a name="l00179"></a>00179     <span class="keywordtype">void</span> ComputeACD(<span class="keyword">const</span> Parameters&amp; params);
<a name="l00180"></a>00180     <span class="keywordtype">void</span> MergeConvexHulls(<span class="keyword">const</span> Parameters&amp; params);
<a name="l00181"></a>00181     <span class="keywordtype">void</span> SimplifyConvexHull(Mesh* <span class="keyword">const</span> ch, <span class="keyword">const</span> <span class="keywordtype">size_t</span> nvertices, <span class="keyword">const</span> <span class="keywordtype">double</span> minVolume);
<a name="l00182"></a>00182     <span class="keywordtype">void</span> SimplifyConvexHulls(<span class="keyword">const</span> Parameters&amp; params);
<a name="l00183"></a>00183     <span class="keywordtype">void</span> ComputeBestClippingPlane(<span class="keyword">const</span> PrimitiveSet* inputPSet,
<a name="l00184"></a>00184         <span class="keyword">const</span> <span class="keywordtype">double</span> volume,
<a name="l00185"></a>00185         <span class="keyword">const</span> SArray&lt;Plane&gt;&amp; planes,
<a name="l00186"></a>00186         <span class="keyword">const</span> Vec3&lt;double&gt;&amp; preferredCuttingDirection,
<a name="l00187"></a>00187         <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="bt_vector3_8h.html#c0e6714ccdb1e845d1c5cc79c057331a" title="Return the w value.">w</a>,
<a name="l00188"></a>00188         <span class="keyword">const</span> <span class="keywordtype">double</span> alpha,
<a name="l00189"></a>00189         <span class="keyword">const</span> <span class="keywordtype">double</span> beta,
<a name="l00190"></a>00190         <span class="keyword">const</span> int32_t convexhullDownsampling,
<a name="l00191"></a>00191         <span class="keyword">const</span> <span class="keywordtype">double</span> progress0,
<a name="l00192"></a>00192         <span class="keyword">const</span> <span class="keywordtype">double</span> progress1,
<a name="l00193"></a>00193         Plane&amp; bestPlane,
<a name="l00194"></a>00194         <span class="keywordtype">double</span>&amp; minConcavity,
<a name="l00195"></a>00195         <span class="keyword">const</span> Parameters&amp; params);
<a name="l00196"></a>00196     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00197"></a>00197     <span class="keywordtype">void</span> AlignMesh(<span class="keyword">const</span> T* <span class="keyword">const</span> points,
<a name="l00198"></a>00198         <span class="keyword">const</span> uint32_t stridePoints,
<a name="l00199"></a>00199         <span class="keyword">const</span> uint32_t nPoints,
<a name="l00200"></a>00200         <span class="keyword">const</span> int32_t* <span class="keyword">const</span> triangles,
<a name="l00201"></a>00201         <span class="keyword">const</span> uint32_t strideTriangles,
<a name="l00202"></a>00202         <span class="keyword">const</span> uint32_t nTriangles,
<a name="l00203"></a>00203         <span class="keyword">const</span> Parameters&amp; params)
<a name="l00204"></a>00204     {
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (GetCancel() || !params.m_pca) {
<a name="l00206"></a>00206             <span class="keywordflow">return</span>;
<a name="l00207"></a>00207         }
<a name="l00208"></a>00208         m_timer.Tic();
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         m_stage = <span class="stringliteral">"Align mesh"</span>;
<a name="l00211"></a>00211         m_operation = <span class="stringliteral">"Voxelization"</span>;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213         std::ostringstream msg;
<a name="l00214"></a>00214         <span class="keywordflow">if</span> (params.m_logger) {
<a name="l00215"></a>00215             msg &lt;&lt; <span class="stringliteral">"+ "</span> &lt;&lt; m_stage &lt;&lt; std::endl;
<a name="l00216"></a>00216             params.m_logger-&gt;Log(msg.str().c_str());
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219         Update(0.0, 0.0, params);
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (GetCancel()) {
<a name="l00221"></a>00221             <span class="keywordflow">return</span>;
<a name="l00222"></a>00222         }
<a name="l00223"></a>00223         m_dim = (size_t)(pow((<span class="keywordtype">double</span>)params.m_resolution, 1.0 / 3.0) + 0.5);
<a name="l00224"></a>00224         Volume volume;
<a name="l00225"></a>00225         volume.Voxelize(points, stridePoints, nPoints,
<a name="l00226"></a>00226             triangles, strideTriangles, nTriangles,
<a name="l00227"></a>00227             m_dim, m_barycenter, m_rot);
<a name="l00228"></a>00228         <span class="keywordtype">size_t</span> n = volume.GetNPrimitivesOnSurf() + volume.GetNPrimitivesInsideSurf();
<a name="l00229"></a>00229         Update(50.0, 100.0, params);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231         <span class="keywordflow">if</span> (params.m_logger) {
<a name="l00232"></a>00232             msg.str(<span class="stringliteral">""</span>);
<a name="l00233"></a>00233             msg &lt;&lt; <span class="stringliteral">"\t dim = "</span> &lt;&lt; m_dim &lt;&lt; <span class="stringliteral">"\t-&gt; "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" voxels"</span> &lt;&lt; std::endl;
<a name="l00234"></a>00234             params.m_logger-&gt;Log(msg.str().c_str());
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236         <span class="keywordflow">if</span> (GetCancel()) {
<a name="l00237"></a>00237             <span class="keywordflow">return</span>;
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239         m_operation = <span class="stringliteral">"PCA"</span>;
<a name="l00240"></a>00240         Update(50.0, 0.0, params);
<a name="l00241"></a>00241         volume.AlignToPrincipalAxes(m_rot);
<a name="l00242"></a>00242         m_overallProgress = 1.0;
<a name="l00243"></a>00243         Update(100.0, 100.0, params);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         m_timer.Toc();
<a name="l00246"></a>00246         <span class="keywordflow">if</span> (params.m_logger) {
<a name="l00247"></a>00247             msg.str(<span class="stringliteral">""</span>);
<a name="l00248"></a>00248             msg &lt;&lt; <span class="stringliteral">"\t time "</span> &lt;&lt; m_timer.GetElapsedTime() / 1000.0 &lt;&lt; <span class="stringliteral">"s"</span> &lt;&lt; std::endl;
<a name="l00249"></a>00249             params.m_logger-&gt;Log(msg.str().c_str());
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251     }
<a name="l00252"></a>00252     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00253"></a>00253     <span class="keywordtype">void</span> VoxelizeMesh(<span class="keyword">const</span> T* <span class="keyword">const</span> points,
<a name="l00254"></a>00254         <span class="keyword">const</span> uint32_t stridePoints,
<a name="l00255"></a>00255         <span class="keyword">const</span> uint32_t nPoints,
<a name="l00256"></a>00256         <span class="keyword">const</span> int32_t* <span class="keyword">const</span> triangles,
<a name="l00257"></a>00257         <span class="keyword">const</span> uint32_t strideTriangles,
<a name="l00258"></a>00258         <span class="keyword">const</span> uint32_t nTriangles,
<a name="l00259"></a>00259         <span class="keyword">const</span> Parameters&amp; params)
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261         <span class="keywordflow">if</span> (GetCancel()) {
<a name="l00262"></a>00262             <span class="keywordflow">return</span>;
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         m_timer.Tic();
<a name="l00266"></a>00266         m_stage = <span class="stringliteral">"Voxelization"</span>;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         std::ostringstream msg;
<a name="l00269"></a>00269         <span class="keywordflow">if</span> (params.m_logger) {
<a name="l00270"></a>00270             msg &lt;&lt; <span class="stringliteral">"+ "</span> &lt;&lt; m_stage &lt;&lt; std::endl;
<a name="l00271"></a>00271             params.m_logger-&gt;Log(msg.str().c_str());
<a name="l00272"></a>00272         }
<a name="l00273"></a>00273 
<a name="l00274"></a>00274         <span class="keyword">delete</span> m_volume;
<a name="l00275"></a>00275         m_volume = 0;
<a name="l00276"></a>00276         int32_t iteration = 0;
<a name="l00277"></a>00277         <span class="keyword">const</span> int32_t maxIteration = 5;
<a name="l00278"></a>00278         <span class="keywordtype">double</span> progress = 0.0;
<a name="l00279"></a>00279         <span class="keywordflow">while</span> (iteration++ &lt; maxIteration &amp;&amp; !m_cancel) {
<a name="l00280"></a>00280             msg.str(<span class="stringliteral">""</span>);
<a name="l00281"></a>00281             msg &lt;&lt; <span class="stringliteral">"Iteration "</span> &lt;&lt; iteration;
<a name="l00282"></a>00282             m_operation = msg.str();
<a name="l00283"></a>00283 
<a name="l00284"></a>00284             progress = iteration * 100.0 / maxIteration;
<a name="l00285"></a>00285             Update(progress, 0.0, params);
<a name="l00286"></a>00286 
<a name="l00287"></a>00287             m_volume = <span class="keyword">new</span> Volume;
<a name="l00288"></a>00288             m_volume-&gt;Voxelize(points, stridePoints, nPoints,
<a name="l00289"></a>00289                 triangles, strideTriangles, nTriangles,
<a name="l00290"></a>00290                 m_dim, m_barycenter, m_rot);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292             Update(progress, 100.0, params);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294             <span class="keywordtype">size_t</span> n = m_volume-&gt;GetNPrimitivesOnSurf() + m_volume-&gt;GetNPrimitivesInsideSurf();
<a name="l00295"></a>00295             <span class="keywordflow">if</span> (params.m_logger) {
<a name="l00296"></a>00296                 msg.str(<span class="stringliteral">""</span>);
<a name="l00297"></a>00297                 msg &lt;&lt; <span class="stringliteral">"\t dim = "</span> &lt;&lt; m_dim &lt;&lt; <span class="stringliteral">"\t-&gt; "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" voxels"</span> &lt;&lt; std::endl;
<a name="l00298"></a>00298                 params.m_logger-&gt;Log(msg.str().c_str());
<a name="l00299"></a>00299             }
<a name="l00300"></a>00300 
<a name="l00301"></a>00301             <span class="keywordtype">double</span> a = pow((<span class="keywordtype">double</span>)(params.m_resolution) / n, 0.33);
<a name="l00302"></a>00302             <span class="keywordtype">size_t</span> dim_next = (size_t)(m_dim * a + 0.5);
<a name="l00303"></a>00303             <span class="keywordflow">if</span> (n &lt; params.m_resolution &amp;&amp; iteration &lt; maxIteration &amp;&amp; m_volume-&gt;GetNPrimitivesOnSurf() &lt; params.m_resolution / 8 &amp;&amp; m_dim != dim_next) {
<a name="l00304"></a>00304                 <span class="keyword">delete</span> m_volume;
<a name="l00305"></a>00305                 m_volume = 0;
<a name="l00306"></a>00306                 m_dim = dim_next;
<a name="l00307"></a>00307             }
<a name="l00308"></a>00308             <span class="keywordflow">else</span> {
<a name="l00309"></a>00309                 <span class="keywordflow">break</span>;
<a name="l00310"></a>00310             }
<a name="l00311"></a>00311         }
<a name="l00312"></a>00312         m_overallProgress = 10.0;
<a name="l00313"></a>00313         Update(100.0, 100.0, params);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315         m_timer.Toc();
<a name="l00316"></a>00316         <span class="keywordflow">if</span> (params.m_logger) {
<a name="l00317"></a>00317             msg.str(<span class="stringliteral">""</span>);
<a name="l00318"></a>00318             msg &lt;&lt; <span class="stringliteral">"\t time "</span> &lt;&lt; m_timer.GetElapsedTime() / 1000.0 &lt;&lt; <span class="stringliteral">"s"</span> &lt;&lt; std::endl;
<a name="l00319"></a>00319             params.m_logger-&gt;Log(msg.str().c_str());
<a name="l00320"></a>00320         }
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00323"></a>00323     <span class="keywordtype">bool</span> ComputeACD(<span class="keyword">const</span> T* <span class="keyword">const</span> points,
<a name="l00324"></a>00324         <span class="keyword">const</span> uint32_t nPoints,
<a name="l00325"></a>00325         <span class="keyword">const</span> uint32_t* <span class="keyword">const</span> triangles,
<a name="l00326"></a>00326         <span class="keyword">const</span> uint32_t nTriangles,
<a name="l00327"></a>00327         <span class="keyword">const</span> Parameters&amp; params)
<a name="l00328"></a>00328     {
<a name="l00329"></a>00329         Init();
<a name="l00330"></a>00330         <span class="keywordflow">if</span> (params.m_projectHullVertices)
<a name="l00331"></a>00331         {
<a name="l00332"></a>00332             mRaycastMesh = <a class="code" href="class_v_h_a_c_d_1_1_raycast_mesh.html#6a1024989eba5ce6650d87780a1b7a3a">RaycastMesh::createRaycastMesh</a>(nPoints, points, nTriangles, (<span class="keyword">const</span> uint32_t *)triangles);
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334         <span class="keywordflow">if</span> (params.m_oclAcceleration) {
<a name="l00335"></a>00335             <span class="comment">// build kernels</span>
<a name="l00336"></a>00336         }
<a name="l00337"></a>00337         AlignMesh(points, 3, nPoints, (int32_t *)triangles, 3, nTriangles, params);
<a name="l00338"></a>00338         VoxelizeMesh(points, 3, nPoints, (int32_t *)triangles, 3, nTriangles, params);
<a name="l00339"></a>00339         ComputePrimitiveSet(params);
<a name="l00340"></a>00340         ComputeACD(params);
<a name="l00341"></a>00341         MergeConvexHulls(params);
<a name="l00342"></a>00342         SimplifyConvexHulls(params);
<a name="l00343"></a>00343         <span class="keywordflow">if</span> (params.m_oclAcceleration) {
<a name="l00344"></a>00344             <span class="comment">// Release kernels</span>
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346         <span class="keywordflow">if</span> (GetCancel()) {
<a name="l00347"></a>00347             <a class="code" href="class_v_h_a_c_d_1_1_v_h_a_c_d.html#6e5ad0c3d528c3df0edb367ca8e8d9dc">Clean</a>();
<a name="l00348"></a>00348             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00349"></a>00349         }
<a name="l00350"></a>00350         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="keyword">private</span>:
<a name="l00354"></a>00354     RaycastMesh     *mRaycastMesh{ <span class="keyword">nullptr</span> };
<a name="l00355"></a>00355     SArray&lt;Mesh*&gt; m_convexHulls;
<a name="l00356"></a>00356     std::string m_stage;
<a name="l00357"></a>00357     std::string m_operation;
<a name="l00358"></a>00358     <span class="keywordtype">double</span> m_overallProgress;
<a name="l00359"></a>00359     <span class="keywordtype">double</span> m_stageProgress;
<a name="l00360"></a>00360     <span class="keywordtype">double</span> m_operationProgress;
<a name="l00361"></a>00361     <span class="keywordtype">double</span> m_rot[3][3];
<a name="l00362"></a>00362     <span class="keywordtype">double</span> m_volumeCH0;
<a name="l00363"></a>00363     Vec3&lt;double&gt; m_barycenter;
<a name="l00364"></a>00364     Timer m_timer;
<a name="l00365"></a>00365     <span class="keywordtype">size_t</span> m_dim;
<a name="l00366"></a>00366     Volume* m_volume;
<a name="l00367"></a>00367     PrimitiveSet* m_pset;
<a name="l00368"></a>00368     Mutex m_cancelMutex;
<a name="l00369"></a>00369     <span class="keywordtype">bool</span> m_cancel;
<a name="l00370"></a>00370     int32_t m_ompNumProcessors;
<a name="l00371"></a>00371 <span class="preprocessor">#ifdef CL_VERSION_1_1</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>    cl_device_id* m_oclDevice;
<a name="l00373"></a>00373     cl_context m_oclContext;
<a name="l00374"></a>00374     cl_program m_oclProgram;
<a name="l00375"></a>00375     cl_command_queue* m_oclQueue;
<a name="l00376"></a>00376     cl_kernel* m_oclKernelComputePartialVolumes;
<a name="l00377"></a>00377     cl_kernel* m_oclKernelComputeSum;
<a name="l00378"></a>00378     <span class="keywordtype">size_t</span> m_oclWorkGroupSize;
<a name="l00379"></a>00379 <span class="preprocessor">#endif //CL_VERSION_1_1</span>
<a name="l00380"></a>00380 <span class="preprocessor"></span>    <a class="code" href="vhacd_v_h_a_c_d_8h.html#7d57e139757b24d6554cca6cf9237335">ConstraintVector</a>        mConstraints;
<a name="l00381"></a>00381 };
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 <span class="preprocessor">#endif // VHACD_VHACD_H</span>
</pre></div></div>
<!-- start footer part -->
<div class="footer">
Copyright &copy; 2015-2017 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</div>
</body>
</html>
